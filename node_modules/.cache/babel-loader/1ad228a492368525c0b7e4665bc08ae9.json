{"ast":null,"code":"/*!\nFullCalendar Scheduler v5.10.2\nDocs & License: https://fullcalendar.io/scheduler\n(c) 2021 Adam Shaw\n*/\nimport './main.css';\nimport { config, createFormatter, greatestDurationDenominator, asCleanDays, createDuration, wholeDivideDurations, asRoughMs, addDays, startOfDay, asRoughSeconds, asRoughMinutes, diffWholeDays, isInt, computeVisibleDayRange, padStart, createElement, ContentHook, BaseComponent, memoizeObjArg, buildClassNameNormalizer, memoize, getDateMeta, getSlotClassNames, getDayClassNames, MountHook, buildNavLinkAttrs, Fragment, rangeContainsMarker, PositionCache, findDirectChildren, createRef, NowTimer, NowIndicatorRoot, findElements, RenderHook, RefMap, multiplyDuration, SegHierarchy, groupIntersectingEntries, buildIsoString, computeEarliestSegStart, buildEventRangeKey, BgEvent, getSegMeta, renderFill, intersectRanges, addMs, Slicer, StandardEvent, MoreLinkRoot, setRef, sortEventSegs, mapHash, isPropsEqual, DateComponent, getStickyHeaderDates, getStickyFooterScrollbar, ViewRoot, renderScrollShim, createPlugin } from '@fullcalendar/common';\nimport premiumCommonPlugin from '@fullcalendar/premium-common';\nimport { __extends, __assign } from 'tslib';\nimport { ScrollGrid } from '@fullcalendar/scrollgrid';\nvar MIN_AUTO_LABELS = 18; // more than `12` months but less that `24` hours\n\nvar MAX_AUTO_SLOTS_PER_LABEL = 6; // allows 6 10-min slots in an hour\n\nvar MAX_AUTO_CELLS = 200; // allows 4-days to have a :30 slot duration\n\nconfig.MAX_TIMELINE_SLOTS = 1000; // potential nice values for slot-duration and interval-duration\n\nvar STOCK_SUB_DURATIONS = [{\n  years: 1\n}, {\n  months: 1\n}, {\n  days: 1\n}, {\n  hours: 1\n}, {\n  minutes: 30\n}, {\n  minutes: 15\n}, {\n  minutes: 10\n}, {\n  minutes: 5\n}, {\n  minutes: 1\n}, {\n  seconds: 30\n}, {\n  seconds: 15\n}, {\n  seconds: 10\n}, {\n  seconds: 5\n}, {\n  seconds: 1\n}, {\n  milliseconds: 500\n}, {\n  milliseconds: 100\n}, {\n  milliseconds: 10\n}, {\n  milliseconds: 1\n}];\n\nfunction buildTimelineDateProfile(dateProfile, dateEnv, allOptions, dateProfileGenerator) {\n  var tDateProfile = {\n    labelInterval: allOptions.slotLabelInterval,\n    slotDuration: allOptions.slotDuration\n  };\n  validateLabelAndSlot(tDateProfile, dateProfile, dateEnv); // validate after computed grid duration\n\n  ensureLabelInterval(tDateProfile, dateProfile, dateEnv);\n  ensureSlotDuration(tDateProfile, dateProfile, dateEnv);\n  var input = allOptions.slotLabelFormat;\n  var rawFormats = Array.isArray(input) ? input : input != null ? [input] : computeHeaderFormats(tDateProfile, dateProfile, dateEnv, allOptions);\n  tDateProfile.headerFormats = rawFormats.map(function (rawFormat) {\n    return createFormatter(rawFormat);\n  });\n  tDateProfile.isTimeScale = Boolean(tDateProfile.slotDuration.milliseconds);\n  var largeUnit = null;\n\n  if (!tDateProfile.isTimeScale) {\n    var slotUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit;\n\n    if (/year|month|week/.test(slotUnit)) {\n      largeUnit = slotUnit;\n    }\n  }\n\n  tDateProfile.largeUnit = largeUnit;\n  tDateProfile.emphasizeWeeks = asCleanDays(tDateProfile.slotDuration) === 1 && currentRangeAs('weeks', dateProfile, dateEnv) >= 2 && !allOptions.businessHours;\n  /*\n  console.log('label interval =', timelineView.labelInterval.humanize())\n  console.log('slot duration =', timelineView.slotDuration.humanize())\n  console.log('header formats =', timelineView.headerFormats)\n  console.log('isTimeScale', timelineView.isTimeScale)\n  console.log('largeUnit', timelineView.largeUnit)\n  */\n\n  var rawSnapDuration = allOptions.snapDuration;\n  var snapDuration;\n  var snapsPerSlot;\n\n  if (rawSnapDuration) {\n    snapDuration = createDuration(rawSnapDuration);\n    snapsPerSlot = wholeDivideDurations(tDateProfile.slotDuration, snapDuration); // ^ TODO: warning if not whole?\n  }\n\n  if (snapsPerSlot == null) {\n    snapDuration = tDateProfile.slotDuration;\n    snapsPerSlot = 1;\n  }\n\n  tDateProfile.snapDuration = snapDuration;\n  tDateProfile.snapsPerSlot = snapsPerSlot; // more...\n\n  var timeWindowMs = asRoughMs(dateProfile.slotMaxTime) - asRoughMs(dateProfile.slotMinTime); // TODO: why not use normalizeRange!?\n\n  var normalizedStart = normalizeDate(dateProfile.renderRange.start, tDateProfile, dateEnv);\n  var normalizedEnd = normalizeDate(dateProfile.renderRange.end, tDateProfile, dateEnv); // apply slotMinTime/slotMaxTime\n  // TODO: View should be responsible.\n\n  if (tDateProfile.isTimeScale) {\n    normalizedStart = dateEnv.add(normalizedStart, dateProfile.slotMinTime);\n    normalizedEnd = dateEnv.add(addDays(normalizedEnd, -1), dateProfile.slotMaxTime);\n  }\n\n  tDateProfile.timeWindowMs = timeWindowMs;\n  tDateProfile.normalizedRange = {\n    start: normalizedStart,\n    end: normalizedEnd\n  };\n  var slotDates = [];\n  var date = normalizedStart;\n\n  while (date < normalizedEnd) {\n    if (isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator)) {\n      slotDates.push(date);\n    }\n\n    date = dateEnv.add(date, tDateProfile.slotDuration);\n  }\n\n  tDateProfile.slotDates = slotDates; // more...\n\n  var snapIndex = -1;\n  var snapDiff = 0; // index of the diff :(\n\n  var snapDiffToIndex = [];\n  var snapIndexToDiff = [];\n  date = normalizedStart;\n\n  while (date < normalizedEnd) {\n    if (isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator)) {\n      snapIndex += 1;\n      snapDiffToIndex.push(snapIndex);\n      snapIndexToDiff.push(snapDiff);\n    } else {\n      snapDiffToIndex.push(snapIndex + 0.5);\n    }\n\n    date = dateEnv.add(date, tDateProfile.snapDuration);\n    snapDiff += 1;\n  }\n\n  tDateProfile.snapDiffToIndex = snapDiffToIndex;\n  tDateProfile.snapIndexToDiff = snapIndexToDiff;\n  tDateProfile.snapCnt = snapIndex + 1; // is always one behind\n\n  tDateProfile.slotCnt = tDateProfile.snapCnt / tDateProfile.snapsPerSlot; // more...\n\n  tDateProfile.isWeekStarts = buildIsWeekStarts(tDateProfile, dateEnv);\n  tDateProfile.cellRows = buildCellRows(tDateProfile, dateEnv);\n  tDateProfile.slotsPerLabel = wholeDivideDurations(tDateProfile.labelInterval, tDateProfile.slotDuration);\n  return tDateProfile;\n}\n/*\nsnaps to appropriate unit\n*/\n\n\nfunction normalizeDate(date, tDateProfile, dateEnv) {\n  var normalDate = date;\n\n  if (!tDateProfile.isTimeScale) {\n    normalDate = startOfDay(normalDate);\n\n    if (tDateProfile.largeUnit) {\n      normalDate = dateEnv.startOf(normalDate, tDateProfile.largeUnit);\n    }\n  }\n\n  return normalDate;\n}\n/*\nsnaps to appropriate unit\n*/\n\n\nfunction normalizeRange(range, tDateProfile, dateEnv) {\n  if (!tDateProfile.isTimeScale) {\n    range = computeVisibleDayRange(range);\n\n    if (tDateProfile.largeUnit) {\n      var dayRange = range; // preserve original result\n\n      range = {\n        start: dateEnv.startOf(range.start, tDateProfile.largeUnit),\n        end: dateEnv.startOf(range.end, tDateProfile.largeUnit)\n      }; // if date is partially through the interval, or is in the same interval as the start,\n      // make the exclusive end be the *next* interval\n\n      if (range.end.valueOf() !== dayRange.end.valueOf() || range.end <= range.start) {\n        range = {\n          start: range.start,\n          end: dateEnv.add(range.end, tDateProfile.slotDuration)\n        };\n      }\n    }\n  }\n\n  return range;\n}\n\nfunction isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator) {\n  if (dateProfileGenerator.isHiddenDay(date)) {\n    return false;\n  }\n\n  if (tDateProfile.isTimeScale) {\n    // determine if the time is within slotMinTime/slotMaxTime, which may have wacky values\n    var day = startOfDay(date);\n    var timeMs = date.valueOf() - day.valueOf();\n    var ms = timeMs - asRoughMs(dateProfile.slotMinTime); // milliseconds since slotMinTime\n\n    ms = (ms % 86400000 + 86400000) % 86400000; // make negative values wrap to 24hr clock\n\n    return ms < tDateProfile.timeWindowMs; // before the slotMaxTime?\n  }\n\n  return true;\n}\n\nfunction validateLabelAndSlot(tDateProfile, dateProfile, dateEnv) {\n  var currentRange = dateProfile.currentRange; // make sure labelInterval doesn't exceed the max number of cells\n\n  if (tDateProfile.labelInterval) {\n    var labelCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, tDateProfile.labelInterval);\n\n    if (labelCnt > config.MAX_TIMELINE_SLOTS) {\n      console.warn('slotLabelInterval results in too many cells');\n      tDateProfile.labelInterval = null;\n    }\n  } // make sure slotDuration doesn't exceed the maximum number of cells\n\n\n  if (tDateProfile.slotDuration) {\n    var slotCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, tDateProfile.slotDuration);\n\n    if (slotCnt > config.MAX_TIMELINE_SLOTS) {\n      console.warn('slotDuration results in too many cells');\n      tDateProfile.slotDuration = null;\n    }\n  } // make sure labelInterval is a multiple of slotDuration\n\n\n  if (tDateProfile.labelInterval && tDateProfile.slotDuration) {\n    var slotsPerLabel = wholeDivideDurations(tDateProfile.labelInterval, tDateProfile.slotDuration);\n\n    if (slotsPerLabel === null || slotsPerLabel < 1) {\n      console.warn('slotLabelInterval must be a multiple of slotDuration');\n      tDateProfile.slotDuration = null;\n    }\n  }\n}\n\nfunction ensureLabelInterval(tDateProfile, dateProfile, dateEnv) {\n  var currentRange = dateProfile.currentRange;\n  var labelInterval = tDateProfile.labelInterval;\n\n  if (!labelInterval) {\n    // compute based off the slot duration\n    // find the largest label interval with an acceptable slots-per-label\n    var input = void 0;\n\n    if (tDateProfile.slotDuration) {\n      for (var _i = 0, STOCK_SUB_DURATIONS_1 = STOCK_SUB_DURATIONS; _i < STOCK_SUB_DURATIONS_1.length; _i++) {\n        input = STOCK_SUB_DURATIONS_1[_i];\n        var tryLabelInterval = createDuration(input);\n        var slotsPerLabel = wholeDivideDurations(tryLabelInterval, tDateProfile.slotDuration);\n\n        if (slotsPerLabel !== null && slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL) {\n          labelInterval = tryLabelInterval;\n          break;\n        }\n      } // use the slot duration as a last resort\n\n\n      if (!labelInterval) {\n        labelInterval = tDateProfile.slotDuration;\n      } // compute based off the view's duration\n      // find the largest label interval that yields the minimum number of labels\n\n    } else {\n      for (var _a = 0, STOCK_SUB_DURATIONS_2 = STOCK_SUB_DURATIONS; _a < STOCK_SUB_DURATIONS_2.length; _a++) {\n        input = STOCK_SUB_DURATIONS_2[_a];\n        labelInterval = createDuration(input);\n        var labelCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, labelInterval);\n\n        if (labelCnt >= MIN_AUTO_LABELS) {\n          break;\n        }\n      }\n    }\n\n    tDateProfile.labelInterval = labelInterval;\n  }\n\n  return labelInterval;\n}\n\nfunction ensureSlotDuration(tDateProfile, dateProfile, dateEnv) {\n  var currentRange = dateProfile.currentRange;\n  var slotDuration = tDateProfile.slotDuration;\n\n  if (!slotDuration) {\n    var labelInterval = ensureLabelInterval(tDateProfile, dateProfile, dateEnv); // will compute if necessary\n    // compute based off the label interval\n    // find the largest slot duration that is different from labelInterval, but still acceptable\n\n    for (var _i = 0, STOCK_SUB_DURATIONS_3 = STOCK_SUB_DURATIONS; _i < STOCK_SUB_DURATIONS_3.length; _i++) {\n      var input = STOCK_SUB_DURATIONS_3[_i];\n      var trySlotDuration = createDuration(input);\n      var slotsPerLabel = wholeDivideDurations(labelInterval, trySlotDuration);\n\n      if (slotsPerLabel !== null && slotsPerLabel > 1 && slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL) {\n        slotDuration = trySlotDuration;\n        break;\n      }\n    } // only allow the value if it won't exceed the view's # of slots limit\n\n\n    if (slotDuration) {\n      var slotCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, slotDuration);\n\n      if (slotCnt > MAX_AUTO_CELLS) {\n        slotDuration = null;\n      }\n    } // use the label interval as a last resort\n\n\n    if (!slotDuration) {\n      slotDuration = labelInterval;\n    }\n\n    tDateProfile.slotDuration = slotDuration;\n  }\n\n  return slotDuration;\n}\n\nfunction computeHeaderFormats(tDateProfile, dateProfile, dateEnv, allOptions) {\n  var format1;\n  var format2;\n  var labelInterval = tDateProfile.labelInterval;\n  var unit = greatestDurationDenominator(labelInterval).unit;\n  var weekNumbersVisible = allOptions.weekNumbers;\n  var format0 = format1 = format2 = null; // NOTE: weekNumber computation function wont work\n\n  if (unit === 'week' && !weekNumbersVisible) {\n    unit = 'day';\n  }\n\n  switch (unit) {\n    case 'year':\n      format0 = {\n        year: 'numeric'\n      }; // '2015'\n\n      break;\n\n    case 'month':\n      if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n        format0 = {\n          year: 'numeric'\n        }; // '2015'\n      }\n\n      format1 = {\n        month: 'short'\n      }; // 'Jan'\n\n      break;\n\n    case 'week':\n      if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n        format0 = {\n          year: 'numeric'\n        }; // '2015'\n      }\n\n      format1 = {\n        week: 'narrow'\n      }; // 'Wk4'\n\n      break;\n\n    case 'day':\n      if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n        format0 = {\n          year: 'numeric',\n          month: 'long'\n        }; // 'January 2014'\n      } else if (currentRangeAs('months', dateProfile, dateEnv) > 1) {\n        format0 = {\n          month: 'long'\n        }; // 'January'\n      }\n\n      if (weekNumbersVisible) {\n        format1 = {\n          week: 'short'\n        }; // 'Wk 4'\n      }\n\n      format2 = {\n        weekday: 'narrow',\n        day: 'numeric'\n      }; // 'Su 9'\n\n      break;\n\n    case 'hour':\n      if (weekNumbersVisible) {\n        format0 = {\n          week: 'short'\n        }; // 'Wk 4'\n      }\n\n      if (currentRangeAs('days', dateProfile, dateEnv) > 1) {\n        format1 = {\n          weekday: 'short',\n          day: 'numeric',\n          month: 'numeric',\n          omitCommas: true\n        }; // Sat 4/7\n      }\n\n      format2 = {\n        hour: 'numeric',\n        minute: '2-digit',\n        omitZeroMinute: true,\n        meridiem: 'short'\n      };\n      break;\n\n    case 'minute':\n      // sufficiently large number of different minute cells?\n      if (asRoughMinutes(labelInterval) / 60 >= MAX_AUTO_SLOTS_PER_LABEL) {\n        format0 = {\n          hour: 'numeric',\n          meridiem: 'short'\n        };\n\n        format1 = function (params) {\n          return ':' + padStart(params.date.minute, 2) // ':30'\n          ;\n        };\n      } else {\n        format0 = {\n          hour: 'numeric',\n          minute: 'numeric',\n          meridiem: 'short'\n        };\n      }\n\n      break;\n\n    case 'second':\n      // sufficiently large number of different second cells?\n      if (asRoughSeconds(labelInterval) / 60 >= MAX_AUTO_SLOTS_PER_LABEL) {\n        format0 = {\n          hour: 'numeric',\n          minute: '2-digit',\n          meridiem: 'lowercase'\n        }; // '8:30 PM'\n\n        format1 = function (params) {\n          return ':' + padStart(params.date.second, 2) // ':30'\n          ;\n        };\n      } else {\n        format0 = {\n          hour: 'numeric',\n          minute: '2-digit',\n          second: '2-digit',\n          meridiem: 'lowercase'\n        }; // '8:30:45 PM'\n      }\n\n      break;\n\n    case 'millisecond':\n      format0 = {\n        hour: 'numeric',\n        minute: '2-digit',\n        second: '2-digit',\n        meridiem: 'lowercase'\n      }; // '8:30:45 PM'\n\n      format1 = function (params) {\n        return '.' + padStart(params.millisecond, 3);\n      };\n\n      break;\n  }\n\n  return [].concat(format0 || [], format1 || [], format2 || []);\n} // Compute the number of the give units in the \"current\" range.\n// Won't go more precise than days.\n// Will return `0` if there's not a clean whole interval.\n\n\nfunction currentRangeAs(unit, dateProfile, dateEnv) {\n  var range = dateProfile.currentRange;\n  var res = null;\n\n  if (unit === 'years') {\n    res = dateEnv.diffWholeYears(range.start, range.end);\n  } else if (unit === 'months') {\n    res = dateEnv.diffWholeMonths(range.start, range.end);\n  } else if (unit === 'weeks') {\n    res = dateEnv.diffWholeMonths(range.start, range.end);\n  } else if (unit === 'days') {\n    res = diffWholeDays(range.start, range.end);\n  }\n\n  return res || 0;\n}\n\nfunction buildIsWeekStarts(tDateProfile, dateEnv) {\n  var slotDates = tDateProfile.slotDates,\n      emphasizeWeeks = tDateProfile.emphasizeWeeks;\n  var prevWeekNumber = null;\n  var isWeekStarts = [];\n\n  for (var _i = 0, slotDates_1 = slotDates; _i < slotDates_1.length; _i++) {\n    var slotDate = slotDates_1[_i];\n    var weekNumber = dateEnv.computeWeekNumber(slotDate);\n    var isWeekStart = emphasizeWeeks && prevWeekNumber !== null && prevWeekNumber !== weekNumber;\n    prevWeekNumber = weekNumber;\n    isWeekStarts.push(isWeekStart);\n  }\n\n  return isWeekStarts;\n}\n\nfunction buildCellRows(tDateProfile, dateEnv) {\n  var slotDates = tDateProfile.slotDates;\n  var formats = tDateProfile.headerFormats;\n  var cellRows = formats.map(function () {\n    return [];\n  }); // indexed by row,col\n\n  var slotAsDays = asCleanDays(tDateProfile.slotDuration);\n  var guessedSlotUnit = slotAsDays === 7 ? 'week' : slotAsDays === 1 ? 'day' : null; // specifically for navclicks\n\n  var rowUnitsFromFormats = formats.map(function (format) {\n    return format.getLargestUnit ? format.getLargestUnit() : null;\n  }); // builds cellRows and slotCells\n\n  for (var i = 0; i < slotDates.length; i += 1) {\n    var date = slotDates[i];\n    var isWeekStart = tDateProfile.isWeekStarts[i];\n\n    for (var row = 0; row < formats.length; row += 1) {\n      var format = formats[row];\n      var rowCells = cellRows[row];\n      var leadingCell = rowCells[rowCells.length - 1];\n      var isLastRow = row === formats.length - 1;\n      var isSuperRow = formats.length > 1 && !isLastRow; // more than one row and not the last\n\n      var newCell = null;\n      var rowUnit = rowUnitsFromFormats[row] || (isLastRow ? guessedSlotUnit : null);\n\n      if (isSuperRow) {\n        var text = dateEnv.format(date, format);\n\n        if (!leadingCell || leadingCell.text !== text) {\n          newCell = buildCellObject(date, text, rowUnit);\n        } else {\n          leadingCell.colspan += 1;\n        }\n      } else if (!leadingCell || isInt(dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, date, tDateProfile.labelInterval))) {\n        var text = dateEnv.format(date, format);\n        newCell = buildCellObject(date, text, rowUnit);\n      } else {\n        leadingCell.colspan += 1;\n      }\n\n      if (newCell) {\n        newCell.weekStart = isWeekStart;\n        rowCells.push(newCell);\n      }\n    }\n  }\n\n  return cellRows;\n}\n\nfunction buildCellObject(date, text, rowUnit) {\n  return {\n    date: date,\n    text: text,\n    rowUnit: rowUnit,\n    colspan: 1,\n    isWeekStart: false\n  };\n}\n\nvar TimelineHeaderThInner =\n/** @class */\nfunction (_super) {\n  __extends(TimelineHeaderThInner, _super);\n\n  function TimelineHeaderThInner() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimelineHeaderThInner.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    return createElement(ContentHook, {\n      hookProps: props.hookProps,\n      content: context.options.slotLabelContent,\n      defaultContent: renderInnerContent\n    }, function (innerElRef, innerContent) {\n      return createElement(\"a\", __assign({\n        ref: innerElRef,\n        className: 'fc-timeline-slot-cushion fc-scrollgrid-sync-inner' + (props.isSticky ? ' fc-sticky' : '')\n      }, props.navLinkAttrs), innerContent);\n    });\n  };\n\n  return TimelineHeaderThInner;\n}(BaseComponent);\n\nfunction renderInnerContent(props) {\n  return props.text;\n}\n\nfunction refineHookProps(input) {\n  return {\n    level: input.level,\n    date: input.dateEnv.toDate(input.dateMarker),\n    view: input.viewApi,\n    text: input.text\n  };\n}\n\nvar TimelineHeaderTh =\n/** @class */\nfunction (_super) {\n  __extends(TimelineHeaderTh, _super);\n\n  function TimelineHeaderTh() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.refineHookProps = memoizeObjArg(refineHookProps);\n    _this.normalizeClassNames = buildClassNameNormalizer();\n    _this.buildCellNavLinkAttrs = memoize(buildCellNavLinkAttrs);\n    return _this;\n  }\n\n  TimelineHeaderTh.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var dateEnv = context.dateEnv,\n        options = context.options;\n    var cell = props.cell,\n        dateProfile = props.dateProfile,\n        tDateProfile = props.tDateProfile; // the cell.rowUnit is f'd\n    // giving 'month' for a 3-day view\n    // workaround: to infer day, do NOT time\n\n    var dateMeta = getDateMeta(cell.date, props.todayRange, props.nowDate, dateProfile);\n    var classNames = ['fc-timeline-slot', 'fc-timeline-slot-label'].concat(cell.rowUnit === 'time' // TODO: so slot classnames for week/month/bigger. see note above about rowUnit\n    ? getSlotClassNames(dateMeta, context.theme) : getDayClassNames(dateMeta, context.theme));\n\n    if (cell.isWeekStart) {\n      classNames.push('fc-timeline-slot-em');\n    }\n\n    var hookProps = this.refineHookProps({\n      level: props.rowLevel,\n      dateMarker: cell.date,\n      text: cell.text,\n      dateEnv: context.dateEnv,\n      viewApi: context.viewApi\n    });\n    var customClassNames = this.normalizeClassNames(options.slotLabelClassNames, hookProps);\n    return createElement(MountHook, {\n      hookProps: hookProps,\n      didMount: options.slotLabelDidMount,\n      willUnmount: options.slotLabelWillUnmount\n    }, function (rootElRef) {\n      return createElement(\"th\", {\n        ref: rootElRef,\n        className: classNames.concat(customClassNames).join(' '),\n        \"data-date\": dateEnv.formatIso(cell.date, {\n          omitTime: !tDateProfile.isTimeScale,\n          omitTimeZoneOffset: true\n        }),\n        colSpan: cell.colspan\n      }, createElement(\"div\", {\n        className: \"fc-timeline-slot-frame\",\n        style: {\n          height: props.rowInnerHeight\n        }\n      }, createElement(TimelineHeaderThInner, {\n        hookProps: hookProps,\n        isSticky: props.isSticky,\n        navLinkAttrs: _this.buildCellNavLinkAttrs(context, cell.date, cell.rowUnit)\n      })));\n    });\n  };\n\n  return TimelineHeaderTh;\n}(BaseComponent);\n\nfunction buildCellNavLinkAttrs(context, cellDate, rowUnit) {\n  return rowUnit && rowUnit !== 'time' ? buildNavLinkAttrs(context, cellDate, rowUnit) : {};\n}\n\nvar TimelineHeaderRows =\n/** @class */\nfunction (_super) {\n  __extends(TimelineHeaderRows, _super);\n\n  function TimelineHeaderRows() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimelineHeaderRows.prototype.render = function () {\n    var _a = this.props,\n        dateProfile = _a.dateProfile,\n        tDateProfile = _a.tDateProfile,\n        rowInnerHeights = _a.rowInnerHeights,\n        todayRange = _a.todayRange,\n        nowDate = _a.nowDate;\n    var cellRows = tDateProfile.cellRows;\n    return createElement(Fragment, null, cellRows.map(function (rowCells, rowLevel) {\n      var isLast = rowLevel === cellRows.length - 1;\n      var isChrono = tDateProfile.isTimeScale && isLast; // the final row, with times?\n\n      var classNames = ['fc-timeline-header-row', isChrono ? 'fc-timeline-header-row-chrono' : ''];\n      return (// eslint-disable-next-line react/no-array-index-key\n        createElement(\"tr\", {\n          key: rowLevel,\n          className: classNames.join(' ')\n        }, rowCells.map(function (cell) {\n          return createElement(TimelineHeaderTh, {\n            key: cell.date.toISOString(),\n            cell: cell,\n            rowLevel: rowLevel,\n            dateProfile: dateProfile,\n            tDateProfile: tDateProfile,\n            todayRange: todayRange,\n            nowDate: nowDate,\n            rowInnerHeight: rowInnerHeights && rowInnerHeights[rowLevel],\n            isSticky: !isLast\n          });\n        }))\n      );\n    }));\n  };\n\n  return TimelineHeaderRows;\n}(BaseComponent);\n\nvar TimelineCoords =\n/** @class */\nfunction () {\n  function TimelineCoords(slatRootEl, // okay to expose?\n  slatEls, dateProfile, tDateProfile, dateEnv, isRtl) {\n    this.slatRootEl = slatRootEl;\n    this.dateProfile = dateProfile;\n    this.tDateProfile = tDateProfile;\n    this.dateEnv = dateEnv;\n    this.isRtl = isRtl;\n    this.outerCoordCache = new PositionCache(slatRootEl, slatEls, true, // isHorizontal\n    false); // for the inner divs within the slats\n    // used for event rendering and scrollTime, to disregard slat border\n\n    this.innerCoordCache = new PositionCache(slatRootEl, findDirectChildren(slatEls, 'div'), true, // isHorizontal\n    false);\n  }\n\n  TimelineCoords.prototype.isDateInRange = function (date) {\n    return rangeContainsMarker(this.dateProfile.currentRange, date);\n  }; // results range from negative width of area to 0\n\n\n  TimelineCoords.prototype.dateToCoord = function (date) {\n    var tDateProfile = this.tDateProfile;\n    var snapCoverage = this.computeDateSnapCoverage(date);\n    var slotCoverage = snapCoverage / tDateProfile.snapsPerSlot;\n    var slotIndex = Math.floor(slotCoverage);\n    slotIndex = Math.min(slotIndex, tDateProfile.slotCnt - 1);\n    var partial = slotCoverage - slotIndex;\n\n    var _a = this,\n        innerCoordCache = _a.innerCoordCache,\n        outerCoordCache = _a.outerCoordCache;\n\n    if (this.isRtl) {\n      return outerCoordCache.originClientRect.width - (outerCoordCache.rights[slotIndex] - innerCoordCache.getWidth(slotIndex) * partial);\n    }\n\n    return outerCoordCache.lefts[slotIndex] + innerCoordCache.getWidth(slotIndex) * partial;\n  };\n\n  TimelineCoords.prototype.rangeToCoords = function (range) {\n    return {\n      start: this.dateToCoord(range.start),\n      end: this.dateToCoord(range.end)\n    };\n  };\n\n  TimelineCoords.prototype.durationToCoord = function (duration) {\n    var _a = this,\n        dateProfile = _a.dateProfile,\n        tDateProfile = _a.tDateProfile,\n        dateEnv = _a.dateEnv,\n        isRtl = _a.isRtl;\n\n    var coord = 0;\n\n    if (dateProfile) {\n      var date = dateEnv.add(dateProfile.activeRange.start, duration);\n\n      if (!tDateProfile.isTimeScale) {\n        date = startOfDay(date);\n      }\n\n      coord = this.dateToCoord(date); // hack to overcome the left borders of non-first slat\n\n      if (!isRtl && coord) {\n        coord += 1;\n      }\n    }\n\n    return coord;\n  };\n\n  TimelineCoords.prototype.coordFromLeft = function (coord) {\n    if (this.isRtl) {\n      return this.outerCoordCache.originClientRect.width - coord;\n    }\n\n    return coord;\n  }; // returned value is between 0 and the number of snaps\n\n\n  TimelineCoords.prototype.computeDateSnapCoverage = function (date) {\n    return computeDateSnapCoverage(date, this.tDateProfile, this.dateEnv);\n  };\n\n  return TimelineCoords;\n}(); // returned value is between 0 and the number of snaps\n\n\nfunction computeDateSnapCoverage(date, tDateProfile, dateEnv) {\n  var snapDiff = dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, date, tDateProfile.snapDuration);\n\n  if (snapDiff < 0) {\n    return 0;\n  }\n\n  if (snapDiff >= tDateProfile.snapDiffToIndex.length) {\n    return tDateProfile.snapCnt;\n  }\n\n  var snapDiffInt = Math.floor(snapDiff);\n  var snapCoverage = tDateProfile.snapDiffToIndex[snapDiffInt];\n\n  if (isInt(snapCoverage)) {\n    // not an in-between value\n    snapCoverage += snapDiff - snapDiffInt; // add the remainder\n  } else {\n    // a fractional value, meaning the date is not visible\n    // always round up in this case. works for start AND end dates in a range.\n    snapCoverage = Math.ceil(snapCoverage);\n  }\n\n  return snapCoverage;\n}\n\nfunction coordToCss(hcoord, isRtl) {\n  if (hcoord === null) {\n    return {\n      left: '',\n      right: ''\n    };\n  }\n\n  if (isRtl) {\n    return {\n      right: hcoord,\n      left: ''\n    };\n  }\n\n  return {\n    left: hcoord,\n    right: ''\n  };\n}\n\nfunction coordsToCss(hcoords, isRtl) {\n  if (!hcoords) {\n    return {\n      left: '',\n      right: ''\n    };\n  }\n\n  if (isRtl) {\n    return {\n      right: hcoords.start,\n      left: -hcoords.end\n    };\n  }\n\n  return {\n    left: hcoords.start,\n    right: -hcoords.end\n  };\n}\n\nvar TimelineHeader =\n/** @class */\nfunction (_super) {\n  __extends(TimelineHeader, _super);\n\n  function TimelineHeader() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.rootElRef = createRef();\n    return _this;\n  }\n\n  TimelineHeader.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        context = _a.context; // TODO: very repetitive\n    // TODO: make part of tDateProfile?\n\n\n    var timerUnit = greatestDurationDenominator(props.tDateProfile.slotDuration).unit; // WORKAROUND: make ignore slatCoords when out of sync with dateProfile\n\n    var slatCoords = props.slatCoords && props.slatCoords.dateProfile === props.dateProfile ? props.slatCoords : null;\n    return createElement(NowTimer, {\n      unit: timerUnit\n    }, function (nowDate, todayRange) {\n      return createElement(\"div\", {\n        className: \"fc-timeline-header\",\n        ref: _this.rootElRef\n      }, createElement(\"table\", {\n        \"aria-hidden\": true,\n        className: \"fc-scrollgrid-sync-table\",\n        style: {\n          minWidth: props.tableMinWidth,\n          width: props.clientWidth\n        }\n      }, props.tableColGroupNode, createElement(\"tbody\", null, createElement(TimelineHeaderRows, {\n        dateProfile: props.dateProfile,\n        tDateProfile: props.tDateProfile,\n        nowDate: nowDate,\n        todayRange: todayRange,\n        rowInnerHeights: props.rowInnerHeights\n      }))), context.options.nowIndicator && // need to have a container regardless of whether the current view has a visible now indicator\n      // because apparently removal of the element resets the scroll for some reasons (issue #5351).\n      // this issue doesn't happen for the timeline body however (\n      createElement(\"div\", {\n        className: \"fc-timeline-now-indicator-container\"\n      }, slatCoords && slatCoords.isDateInRange(nowDate) && createElement(NowIndicatorRoot, {\n        isAxis: true,\n        date: nowDate\n      }, function (rootElRef, classNames, innerElRef, innerContent) {\n        return createElement(\"div\", {\n          ref: rootElRef,\n          className: ['fc-timeline-now-indicator-arrow'].concat(classNames).join(' '),\n          style: coordToCss(slatCoords.dateToCoord(nowDate), context.isRtl)\n        }, innerContent);\n      })));\n    });\n  };\n\n  TimelineHeader.prototype.componentDidMount = function () {\n    this.updateSize();\n  };\n\n  TimelineHeader.prototype.componentDidUpdate = function () {\n    this.updateSize();\n  };\n\n  TimelineHeader.prototype.updateSize = function () {\n    if (this.props.onMaxCushionWidth) {\n      this.props.onMaxCushionWidth(this.computeMaxCushionWidth());\n    }\n  };\n\n  TimelineHeader.prototype.computeMaxCushionWidth = function () {\n    return Math.max.apply(Math, findElements(this.rootElRef.current, '.fc-timeline-header-row:last-child .fc-timeline-slot-cushion').map(function (el) {\n      return el.getBoundingClientRect().width;\n    }));\n  };\n\n  return TimelineHeader;\n}(BaseComponent);\n\nvar TimelineSlatCell =\n/** @class */\nfunction (_super) {\n  __extends(TimelineSlatCell, _super);\n\n  function TimelineSlatCell() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimelineSlatCell.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var dateEnv = context.dateEnv,\n        options = context.options,\n        theme = context.theme;\n    var date = props.date,\n        tDateProfile = props.tDateProfile,\n        isEm = props.isEm;\n    var dateMeta = getDateMeta(props.date, props.todayRange, props.nowDate, props.dateProfile);\n    var classNames = ['fc-timeline-slot', 'fc-timeline-slot-lane'];\n    var dataAttrs = {\n      'data-date': dateEnv.formatIso(date, {\n        omitTimeZoneOffset: true,\n        omitTime: !tDateProfile.isTimeScale\n      })\n    };\n\n    var hookProps = __assign(__assign({\n      date: dateEnv.toDate(props.date)\n    }, dateMeta), {\n      view: context.viewApi\n    });\n\n    if (isEm) {\n      classNames.push('fc-timeline-slot-em');\n    }\n\n    if (tDateProfile.isTimeScale) {\n      classNames.push(isInt(dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, props.date, tDateProfile.labelInterval)) ? 'fc-timeline-slot-major' : 'fc-timeline-slot-minor');\n    }\n\n    classNames.push.apply(classNames, props.isDay ? getDayClassNames(dateMeta, theme) : getSlotClassNames(dateMeta, theme));\n    return createElement(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.slotLaneClassNames,\n      content: options.slotLaneContent,\n      didMount: options.slotLaneDidMount,\n      willUnmount: options.slotLaneWillUnmount,\n      elRef: props.elRef\n    }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n      return createElement(\"td\", __assign({\n        ref: rootElRef,\n        className: classNames.concat(customClassNames).join(' ')\n      }, dataAttrs), createElement(\"div\", {\n        ref: innerElRef\n      }, innerContent));\n    });\n  };\n\n  return TimelineSlatCell;\n}(BaseComponent);\n\nvar TimelineSlatsBody =\n/** @class */\nfunction (_super) {\n  __extends(TimelineSlatsBody, _super);\n\n  function TimelineSlatsBody() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimelineSlatsBody.prototype.render = function () {\n    var props = this.props;\n    var tDateProfile = props.tDateProfile,\n        cellElRefs = props.cellElRefs;\n    var slotDates = tDateProfile.slotDates,\n        isWeekStarts = tDateProfile.isWeekStarts;\n    var isDay = !tDateProfile.isTimeScale && !tDateProfile.largeUnit;\n    return createElement(\"tbody\", null, createElement(\"tr\", null, slotDates.map(function (slotDate, i) {\n      var key = slotDate.toISOString();\n      return createElement(TimelineSlatCell, {\n        key: key,\n        elRef: cellElRefs.createRef(key),\n        date: slotDate,\n        dateProfile: props.dateProfile,\n        tDateProfile: tDateProfile,\n        nowDate: props.nowDate,\n        todayRange: props.todayRange,\n        isEm: isWeekStarts[i],\n        isDay: isDay\n      });\n    })));\n  };\n\n  return TimelineSlatsBody;\n}(BaseComponent);\n\nvar TimelineSlats =\n/** @class */\nfunction (_super) {\n  __extends(TimelineSlats, _super);\n\n  function TimelineSlats() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.rootElRef = createRef();\n    _this.cellElRefs = new RefMap();\n\n    _this.handleScrollRequest = function (request) {\n      var onScrollLeftRequest = _this.props.onScrollLeftRequest;\n      var coords = _this.coords;\n\n      if (onScrollLeftRequest && coords) {\n        if (request.time) {\n          var scrollLeft = coords.coordFromLeft(coords.durationToCoord(request.time));\n          onScrollLeftRequest(scrollLeft);\n        }\n\n        return true;\n      }\n\n      return null; // best?\n    };\n\n    return _this;\n  }\n\n  TimelineSlats.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    return createElement(\"div\", {\n      className: \"fc-timeline-slots\",\n      ref: this.rootElRef\n    }, createElement(\"table\", {\n      \"aria-hidden\": true,\n      className: context.theme.getClass('table'),\n      style: {\n        minWidth: props.tableMinWidth,\n        width: props.clientWidth\n      }\n    }, props.tableColGroupNode, createElement(TimelineSlatsBody, {\n      cellElRefs: this.cellElRefs,\n      dateProfile: props.dateProfile,\n      tDateProfile: props.tDateProfile,\n      nowDate: props.nowDate,\n      todayRange: props.todayRange\n    })));\n  };\n\n  TimelineSlats.prototype.componentDidMount = function () {\n    this.updateSizing();\n    this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);\n  };\n\n  TimelineSlats.prototype.componentDidUpdate = function (prevProps) {\n    this.updateSizing();\n    this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);\n  };\n\n  TimelineSlats.prototype.componentWillUnmount = function () {\n    this.scrollResponder.detach();\n\n    if (this.props.onCoords) {\n      this.props.onCoords(null);\n    }\n  };\n\n  TimelineSlats.prototype.updateSizing = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    if (props.clientWidth !== null && // is sizing stable?\n    this.scrollResponder // ^it's possible to have clientWidth immediately after mount (when returning from print view), but w/o scrollResponder\n    ) {\n      var rootEl = this.rootElRef.current;\n\n      if (rootEl.offsetWidth) {\n        // not hidden by css\n        this.coords = new TimelineCoords(this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.tDateProfile.slotDates), props.dateProfile, props.tDateProfile, context.dateEnv, context.isRtl);\n\n        if (props.onCoords) {\n          props.onCoords(this.coords);\n        }\n\n        this.scrollResponder.update(false); // TODO: wouldn't have to do this if coords were in state\n      }\n    }\n  };\n\n  TimelineSlats.prototype.positionToHit = function (leftPosition) {\n    var outerCoordCache = this.coords.outerCoordCache;\n    var _a = this.context,\n        dateEnv = _a.dateEnv,\n        isRtl = _a.isRtl;\n    var tDateProfile = this.props.tDateProfile;\n    var slatIndex = outerCoordCache.leftToIndex(leftPosition);\n\n    if (slatIndex != null) {\n      // somewhat similar to what TimeGrid does. consolidate?\n      var slatWidth = outerCoordCache.getWidth(slatIndex);\n      var partial = isRtl ? (outerCoordCache.rights[slatIndex] - leftPosition) / slatWidth : (leftPosition - outerCoordCache.lefts[slatIndex]) / slatWidth;\n      var localSnapIndex = Math.floor(partial * tDateProfile.snapsPerSlot);\n      var start = dateEnv.add(tDateProfile.slotDates[slatIndex], multiplyDuration(tDateProfile.snapDuration, localSnapIndex));\n      var end = dateEnv.add(start, tDateProfile.snapDuration);\n      return {\n        dateSpan: {\n          range: {\n            start: start,\n            end: end\n          },\n          allDay: !this.props.tDateProfile.isTimeScale\n        },\n        dayEl: this.cellElRefs.currentMap[slatIndex],\n        left: outerCoordCache.lefts[slatIndex],\n        right: outerCoordCache.rights[slatIndex]\n      };\n    }\n\n    return null;\n  };\n\n  return TimelineSlats;\n}(BaseComponent);\n\nfunction collectCellEls(elMap, slotDates) {\n  return slotDates.map(function (slotDate) {\n    var key = slotDate.toISOString();\n    return elMap[key];\n  });\n}\n\nfunction computeSegHCoords(segs, minWidth, timelineCoords) {\n  var hcoords = [];\n\n  if (timelineCoords) {\n    for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n      var seg = segs_1[_i];\n      var res = timelineCoords.rangeToCoords(seg);\n      var start = Math.round(res.start); // for barely-overlapping collisions\n\n      var end = Math.round(res.end); //\n\n      if (end - start < minWidth) {\n        end = start + minWidth;\n      }\n\n      hcoords.push({\n        start: start,\n        end: end\n      });\n    }\n  }\n\n  return hcoords;\n}\n\nfunction computeFgSegPlacements(segs, segHCoords, // might not have for every seg\neventInstanceHeights, // might not have for every seg\nmoreLinkHeights, // might not have for every more-link\nstrictOrder, maxStackCnt) {\n  var segInputs = [];\n  var crudePlacements = []; // when we don't know dims\n\n  for (var i = 0; i < segs.length; i += 1) {\n    var seg = segs[i];\n    var instanceId = seg.eventRange.instance.instanceId;\n    var height = eventInstanceHeights[instanceId];\n    var hcoords = segHCoords[i];\n\n    if (height && hcoords) {\n      segInputs.push({\n        index: i,\n        span: hcoords,\n        thickness: height\n      });\n    } else {\n      crudePlacements.push({\n        seg: seg,\n        hcoords: hcoords,\n        top: null\n      });\n    }\n  }\n\n  var hierarchy = new SegHierarchy();\n\n  if (strictOrder != null) {\n    hierarchy.strictOrder = strictOrder;\n  }\n\n  if (maxStackCnt != null) {\n    hierarchy.maxStackCnt = maxStackCnt;\n  }\n\n  var hiddenEntries = hierarchy.addSegs(segInputs);\n  var hiddenPlacements = hiddenEntries.map(function (entry) {\n    return {\n      seg: segs[entry.index],\n      hcoords: entry.span,\n      top: null\n    };\n  });\n  var hiddenGroups = groupIntersectingEntries(hiddenEntries);\n  var moreLinkInputs = [];\n  var moreLinkCrudePlacements = [];\n\n  var extractSeg = function (entry) {\n    return segs[entry.index];\n  };\n\n  for (var i = 0; i < hiddenGroups.length; i += 1) {\n    var hiddenGroup = hiddenGroups[i];\n    var sortedSegs = hiddenGroup.entries.map(extractSeg);\n    var height = moreLinkHeights[buildIsoString(computeEarliestSegStart(sortedSegs))]; // not optimal :(\n\n    if (height != null) {\n      // NOTE: the hiddenGroup's spanStart/spanEnd are already computed by rangeToCoords. computed during input.\n      moreLinkInputs.push({\n        index: segs.length + i,\n        thickness: height,\n        span: hiddenGroup.span\n      });\n    } else {\n      moreLinkCrudePlacements.push({\n        seg: sortedSegs,\n        hcoords: hiddenGroup.span,\n        top: null\n      });\n    }\n  } // add more-links into the hierarchy, but don't limit\n\n\n  hierarchy.maxStackCnt = -1;\n  hierarchy.addSegs(moreLinkInputs);\n  var visibleRects = hierarchy.toRects();\n  var visiblePlacements = [];\n  var maxHeight = 0;\n\n  for (var _i = 0, visibleRects_1 = visibleRects; _i < visibleRects_1.length; _i++) {\n    var rect = visibleRects_1[_i];\n    var segIndex = rect.index;\n    visiblePlacements.push({\n      seg: segIndex < segs.length ? segs[segIndex] // a real seg\n      : hiddenGroups[segIndex - segs.length].entries.map(extractSeg),\n      hcoords: rect.span,\n      top: rect.levelCoord\n    });\n    maxHeight = Math.max(maxHeight, rect.levelCoord + rect.thickness);\n  }\n\n  return [visiblePlacements.concat(crudePlacements, hiddenPlacements, moreLinkCrudePlacements), maxHeight];\n}\n\nvar TimelineLaneBg =\n/** @class */\nfunction (_super) {\n  __extends(TimelineLaneBg, _super);\n\n  function TimelineLaneBg() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimelineLaneBg.prototype.render = function () {\n    var props = this.props;\n    var highlightSeg = [].concat(props.eventResizeSegs, props.dateSelectionSegs);\n    return props.timelineCoords && createElement(\"div\", {\n      className: \"fc-timeline-bg\"\n    }, this.renderSegs(props.businessHourSegs || [], props.timelineCoords, 'non-business'), this.renderSegs(props.bgEventSegs || [], props.timelineCoords, 'bg-event'), this.renderSegs(highlightSeg, props.timelineCoords, 'highlight'));\n  };\n\n  TimelineLaneBg.prototype.renderSegs = function (segs, timelineCoords, fillType) {\n    var _a = this.props,\n        todayRange = _a.todayRange,\n        nowDate = _a.nowDate;\n    var isRtl = this.context.isRtl;\n    var segHCoords = computeSegHCoords(segs, 0, timelineCoords);\n    var children = segs.map(function (seg, i) {\n      var hcoords = segHCoords[i];\n      var hStyle = coordsToCss(hcoords, isRtl);\n      return createElement(\"div\", {\n        key: buildEventRangeKey(seg.eventRange),\n        className: \"fc-timeline-bg-harness\",\n        style: hStyle\n      }, fillType === 'bg-event' ? createElement(BgEvent, __assign({\n        seg: seg\n      }, getSegMeta(seg, todayRange, nowDate))) : renderFill(fillType));\n    });\n    return createElement(Fragment, null, children);\n  };\n\n  return TimelineLaneBg;\n}(BaseComponent);\n\nvar TimelineLaneSlicer =\n/** @class */\nfunction (_super) {\n  __extends(TimelineLaneSlicer, _super);\n\n  function TimelineLaneSlicer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimelineLaneSlicer.prototype.sliceRange = function (origRange, dateProfile, dateProfileGenerator, tDateProfile, dateEnv) {\n    var normalRange = normalizeRange(origRange, tDateProfile, dateEnv);\n    var segs = []; // protect against when the span is entirely in an invalid date region\n\n    if (computeDateSnapCoverage(normalRange.start, tDateProfile, dateEnv) < computeDateSnapCoverage(normalRange.end, tDateProfile, dateEnv)) {\n      // intersect the footprint's range with the grid's range\n      var slicedRange = intersectRanges(normalRange, tDateProfile.normalizedRange);\n\n      if (slicedRange) {\n        segs.push({\n          start: slicedRange.start,\n          end: slicedRange.end,\n          isStart: slicedRange.start.valueOf() === normalRange.start.valueOf() && isValidDate(slicedRange.start, tDateProfile, dateProfile, dateProfileGenerator),\n          isEnd: slicedRange.end.valueOf() === normalRange.end.valueOf() && isValidDate(addMs(slicedRange.end, -1), tDateProfile, dateProfile, dateProfileGenerator)\n        });\n      }\n    }\n\n    return segs;\n  };\n\n  return TimelineLaneSlicer;\n}(Slicer);\n\nvar DEFAULT_TIME_FORMAT = createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  omitZeroMinute: true,\n  meridiem: 'narrow'\n});\n\nvar TimelineEvent =\n/** @class */\nfunction (_super) {\n  __extends(TimelineEvent, _super);\n\n  function TimelineEvent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimelineEvent.prototype.render = function () {\n    var props = this.props;\n    return createElement(StandardEvent, __assign({}, props, {\n      extraClassNames: ['fc-timeline-event', 'fc-h-event'],\n      defaultTimeFormat: DEFAULT_TIME_FORMAT,\n      defaultDisplayEventTime: !props.isTimeScale\n    }));\n  };\n\n  return TimelineEvent;\n}(BaseComponent);\n\nvar TimelineLaneMoreLink =\n/** @class */\nfunction (_super) {\n  __extends(TimelineLaneMoreLink, _super);\n\n  function TimelineLaneMoreLink() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.rootElRef = createRef();\n    return _this;\n  }\n\n  TimelineLaneMoreLink.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var hiddenSegs = props.hiddenSegs,\n        elRef = props.elRef,\n        placement = props.placement,\n        resourceId = props.resourceId;\n    var top = placement.top,\n        hcoords = placement.hcoords;\n    var isVisible = hcoords && top !== null;\n    var hStyle = coordsToCss(hcoords, context.isRtl);\n    var extraDateSpan = resourceId ? {\n      resourceId: resourceId\n    } : {};\n    return createElement(MoreLinkRoot, {\n      allDayDate: null,\n      moreCnt: hiddenSegs.length,\n      allSegs: hiddenSegs,\n      hiddenSegs: hiddenSegs,\n      alignmentElRef: this.rootElRef,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      extraDateSpan: extraDateSpan,\n      popoverContent: function () {\n        return createElement(Fragment, null, hiddenSegs.map(function (seg) {\n          var instanceId = seg.eventRange.instance.instanceId;\n          return createElement(\"div\", {\n            key: instanceId,\n            style: {\n              visibility: props.isForcedInvisible[instanceId] ? 'hidden' : ''\n            }\n          }, createElement(TimelineEvent, __assign({\n            isTimeScale: props.isTimeScale,\n            seg: seg,\n            isDragging: false,\n            isResizing: false,\n            isDateSelecting: false,\n            isSelected: instanceId === props.eventSelection\n          }, getSegMeta(seg, props.todayRange, props.nowDate))));\n        }));\n      }\n    }, function (rootElRef, classNames, innerElRef, innerContent, handleClick, title, isExpanded, popoverId) {\n      return createElement(\"a\", {\n        ref: function (el) {\n          setRef(rootElRef, el); // for MoreLinkRoot\n\n          setRef(elRef, el); // for props props\n\n          setRef(_this.rootElRef, el); // for this component\n        },\n        className: ['fc-timeline-more-link'].concat(classNames).join(' '),\n        style: __assign({\n          visibility: isVisible ? '' : 'hidden',\n          top: top || 0\n        }, hStyle),\n        onClick: handleClick,\n        title: title,\n        \"aria-expanded\": isExpanded,\n        \"aria-controls\": popoverId\n      }, createElement(\"div\", {\n        ref: innerElRef,\n        className: \"fc-timeline-more-link-inner fc-sticky\"\n      }, innerContent));\n    });\n  };\n\n  return TimelineLaneMoreLink;\n}(BaseComponent);\n\nvar TimelineLane =\n/** @class */\nfunction (_super) {\n  __extends(TimelineLane, _super);\n\n  function TimelineLane() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.slicer = new TimelineLaneSlicer();\n    _this.sortEventSegs = memoize(sortEventSegs);\n    _this.harnessElRefs = new RefMap();\n    _this.moreElRefs = new RefMap();\n    _this.innerElRef = createRef(); // TODO: memoize event positioning\n\n    _this.state = {\n      eventInstanceHeights: {},\n      moreLinkHeights: {}\n    };\n    return _this;\n  }\n\n  TimelineLane.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        state = _a.state,\n        context = _a.context;\n\n    var options = context.options;\n    var dateProfile = props.dateProfile,\n        tDateProfile = props.tDateProfile;\n    var slicedProps = this.slicer.sliceProps(props, dateProfile, tDateProfile.isTimeScale ? null : props.nextDayThreshold, context, // wish we didn't have to pass in the rest of the args...\n    dateProfile, context.dateProfileGenerator, tDateProfile, context.dateEnv);\n    var mirrorSegs = (slicedProps.eventDrag ? slicedProps.eventDrag.segs : null) || (slicedProps.eventResize ? slicedProps.eventResize.segs : null) || [];\n    var fgSegs = this.sortEventSegs(slicedProps.fgEventSegs, options.eventOrder);\n    var fgSegHCoords = computeSegHCoords(fgSegs, options.eventMinWidth, props.timelineCoords);\n\n    var _b = computeFgSegPlacements(fgSegs, fgSegHCoords, state.eventInstanceHeights, state.moreLinkHeights, options.eventOrderStrict, options.eventMaxStack),\n        fgPlacements = _b[0],\n        fgHeight = _b[1];\n\n    var isForcedInvisible = // TODO: more convenient\n    (slicedProps.eventDrag ? slicedProps.eventDrag.affectedInstances : null) || (slicedProps.eventResize ? slicedProps.eventResize.affectedInstances : null) || {};\n    return createElement(Fragment, null, createElement(TimelineLaneBg, {\n      businessHourSegs: slicedProps.businessHourSegs,\n      bgEventSegs: slicedProps.bgEventSegs,\n      timelineCoords: props.timelineCoords,\n      eventResizeSegs: slicedProps.eventResize ? slicedProps.eventResize.segs : []\n      /* bad new empty array? */\n      ,\n      dateSelectionSegs: slicedProps.dateSelectionSegs,\n      nowDate: props.nowDate,\n      todayRange: props.todayRange\n    }), createElement(\"div\", {\n      className: \"fc-timeline-events fc-scrollgrid-sync-inner\",\n      ref: this.innerElRef,\n      style: {\n        height: fgHeight\n      }\n    }, this.renderFgSegs(fgPlacements, isForcedInvisible, false, false, false), this.renderFgSegs(buildMirrorPlacements(mirrorSegs, props.timelineCoords, fgPlacements), {}, Boolean(slicedProps.eventDrag), Boolean(slicedProps.eventResize), false)));\n  };\n\n  TimelineLane.prototype.componentDidMount = function () {\n    this.updateSize();\n  };\n\n  TimelineLane.prototype.componentDidUpdate = function (prevProps, prevState) {\n    if (prevProps.eventStore !== this.props.eventStore || // external thing changed?\n    prevProps.timelineCoords !== this.props.timelineCoords || // external thing changed?\n    prevState.moreLinkHeights !== this.state.moreLinkHeights // HACK. see addStateEquality\n    ) {\n      this.updateSize();\n    }\n  };\n\n  TimelineLane.prototype.updateSize = function () {\n    var _this = this;\n\n    var props = this.props;\n    var timelineCoords = props.timelineCoords;\n\n    if (props.onHeightChange) {\n      props.onHeightChange(this.innerElRef.current, false);\n    }\n\n    if (timelineCoords) {\n      this.setState({\n        eventInstanceHeights: mapHash(this.harnessElRefs.currentMap, function (harnessEl) {\n          return Math.round(harnessEl.getBoundingClientRect().height);\n        }),\n        moreLinkHeights: mapHash(this.moreElRefs.currentMap, function (moreEl) {\n          return Math.round(moreEl.getBoundingClientRect().height);\n        })\n      }, function () {\n        if (props.onHeightChange) {\n          props.onHeightChange(_this.innerElRef.current, true);\n        }\n      });\n    }\n  };\n\n  TimelineLane.prototype.renderFgSegs = function (segPlacements, isForcedInvisible, isDragging, isResizing, isDateSelecting) {\n    var _a = this,\n        harnessElRefs = _a.harnessElRefs,\n        moreElRefs = _a.moreElRefs,\n        props = _a.props,\n        context = _a.context;\n\n    var isMirror = isDragging || isResizing || isDateSelecting;\n    return createElement(Fragment, null, segPlacements.map(function (segPlacement) {\n      var seg = segPlacement.seg,\n          hcoords = segPlacement.hcoords,\n          top = segPlacement.top;\n\n      if (Array.isArray(seg)) {\n        // a more-link\n        var isoStr = buildIsoString(computeEarliestSegStart(seg));\n        return createElement(TimelineLaneMoreLink, {\n          key: 'm:' + isoStr\n          /* \"m\" for \"more\" */\n          ,\n          elRef: moreElRefs.createRef(isoStr),\n          hiddenSegs: seg,\n          placement: segPlacement,\n          dateProfile: props.dateProfile,\n          nowDate: props.nowDate,\n          todayRange: props.todayRange,\n          isTimeScale: props.tDateProfile.isTimeScale,\n          eventSelection: props.eventSelection,\n          resourceId: props.resourceId,\n          isForcedInvisible: isForcedInvisible\n        });\n      }\n\n      var instanceId = seg.eventRange.instance.instanceId;\n      var isVisible = isMirror || Boolean(!isForcedInvisible[instanceId] && hcoords && top !== null);\n      var hStyle = coordsToCss(hcoords, context.isRtl);\n      return createElement(\"div\", {\n        key: 'e:' + instanceId\n        /* \"e\" for \"event\" */\n        ,\n        ref: isMirror ? null : harnessElRefs.createRef(instanceId),\n        className: \"fc-timeline-event-harness\",\n        style: __assign({\n          visibility: isVisible ? '' : 'hidden',\n          top: top || 0\n        }, hStyle)\n      }, createElement(TimelineEvent, __assign({\n        isTimeScale: props.tDateProfile.isTimeScale,\n        seg: seg,\n        isDragging: isDragging,\n        isResizing: isResizing,\n        isDateSelecting: isDateSelecting,\n        isSelected: instanceId === props.eventSelection\n        /* TODO: bad for mirror? */\n\n      }, getSegMeta(seg, props.todayRange, props.nowDate))));\n    }));\n  };\n\n  return TimelineLane;\n}(BaseComponent);\n\nTimelineLane.addStateEquality({\n  eventInstanceHeights: isPropsEqual,\n  moreLinkHeights: isPropsEqual\n});\n\nfunction buildMirrorPlacements(mirrorSegs, timelineCoords, fgPlacements) {\n  if (!mirrorSegs.length || !timelineCoords) {\n    return [];\n  }\n\n  var topsByInstanceId = buildAbsoluteTopHash(fgPlacements); // TODO: cache this at first render?\n\n  return mirrorSegs.map(function (seg) {\n    return {\n      seg: seg,\n      hcoords: timelineCoords.rangeToCoords(seg),\n      top: topsByInstanceId[seg.eventRange.instance.instanceId]\n    };\n  });\n}\n\nfunction buildAbsoluteTopHash(placements) {\n  var topsByInstanceId = {};\n\n  for (var _i = 0, placements_1 = placements; _i < placements_1.length; _i++) {\n    var placement = placements_1[_i];\n    var seg = placement.seg;\n\n    if (!Array.isArray(seg)) {\n      // doesn't represent a more-link\n      topsByInstanceId[seg.eventRange.instance.instanceId] = placement.top;\n    }\n  }\n\n  return topsByInstanceId;\n}\n\nvar TimelineGrid =\n/** @class */\nfunction (_super) {\n  __extends(TimelineGrid, _super);\n\n  function TimelineGrid() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.slatsRef = createRef();\n    _this.state = {\n      coords: null\n    };\n\n    _this.handeEl = function (el) {\n      if (el) {\n        _this.context.registerInteractiveComponent(_this, {\n          el: el\n        });\n      } else {\n        _this.context.unregisterInteractiveComponent(_this);\n      }\n    };\n\n    _this.handleCoords = function (coords) {\n      _this.setState({\n        coords: coords\n      });\n\n      if (_this.props.onSlatCoords) {\n        _this.props.onSlatCoords(coords);\n      }\n    };\n\n    return _this;\n  }\n\n  TimelineGrid.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        state = _a.state,\n        context = _a.context;\n\n    var options = context.options;\n    var dateProfile = props.dateProfile,\n        tDateProfile = props.tDateProfile;\n    var timerUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit;\n    return createElement(\"div\", {\n      className: \"fc-timeline-body\",\n      ref: this.handeEl,\n      style: {\n        minWidth: props.tableMinWidth,\n        height: props.clientHeight,\n        width: props.clientWidth\n      }\n    }, createElement(NowTimer, {\n      unit: timerUnit\n    }, function (nowDate, todayRange) {\n      return createElement(Fragment, null, createElement(TimelineSlats, {\n        ref: _this.slatsRef,\n        dateProfile: dateProfile,\n        tDateProfile: tDateProfile,\n        nowDate: nowDate,\n        todayRange: todayRange,\n        clientWidth: props.clientWidth,\n        tableColGroupNode: props.tableColGroupNode,\n        tableMinWidth: props.tableMinWidth,\n        onCoords: _this.handleCoords,\n        onScrollLeftRequest: props.onScrollLeftRequest\n      }), createElement(TimelineLane, {\n        dateProfile: dateProfile,\n        tDateProfile: props.tDateProfile,\n        nowDate: nowDate,\n        todayRange: todayRange,\n        nextDayThreshold: options.nextDayThreshold,\n        businessHours: props.businessHours,\n        eventStore: props.eventStore,\n        eventUiBases: props.eventUiBases,\n        dateSelection: props.dateSelection,\n        eventSelection: props.eventSelection,\n        eventDrag: props.eventDrag,\n        eventResize: props.eventResize,\n        timelineCoords: state.coords\n      }), options.nowIndicator && state.coords && state.coords.isDateInRange(nowDate) && createElement(\"div\", {\n        className: \"fc-timeline-now-indicator-container\"\n      }, createElement(NowIndicatorRoot, {\n        isAxis: false,\n        date: nowDate\n      }, function (rootElRef, classNames, innerElRef, innerContent) {\n        return createElement(\"div\", {\n          ref: rootElRef,\n          className: ['fc-timeline-now-indicator-line'].concat(classNames).join(' '),\n          style: coordToCss(state.coords.dateToCoord(nowDate), context.isRtl)\n        }, innerContent);\n      })));\n    }));\n  }; // Hit System\n  // ------------------------------------------------------------------------------------------\n\n\n  TimelineGrid.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {\n    var slats = this.slatsRef.current;\n    var slatHit = slats.positionToHit(positionLeft);\n\n    if (slatHit) {\n      return {\n        dateProfile: this.props.dateProfile,\n        dateSpan: slatHit.dateSpan,\n        rect: {\n          left: slatHit.left,\n          right: slatHit.right,\n          top: 0,\n          bottom: elHeight\n        },\n        dayEl: slatHit.dayEl,\n        layer: 0\n      };\n    }\n\n    return null;\n  };\n\n  return TimelineGrid;\n}(DateComponent);\n\nvar TimelineView =\n/** @class */\nfunction (_super) {\n  __extends(TimelineView, _super);\n\n  function TimelineView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.buildTimelineDateProfile = memoize(buildTimelineDateProfile);\n    _this.scrollGridRef = createRef();\n    _this.state = {\n      slatCoords: null,\n      slotCushionMaxWidth: null\n    };\n\n    _this.handleSlatCoords = function (slatCoords) {\n      _this.setState({\n        slatCoords: slatCoords\n      });\n    };\n\n    _this.handleScrollLeftRequest = function (scrollLeft) {\n      var scrollGrid = _this.scrollGridRef.current;\n      scrollGrid.forceScrollLeft(0, scrollLeft);\n    };\n\n    _this.handleMaxCushionWidth = function (slotCushionMaxWidth) {\n      _this.setState({\n        slotCushionMaxWidth: Math.ceil(slotCushionMaxWidth) // for less rerendering TODO: DRY\n\n      });\n    };\n\n    return _this;\n  }\n\n  TimelineView.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        state = _a.state,\n        context = _a.context;\n\n    var options = context.options;\n    var stickyHeaderDates = !props.forPrint && getStickyHeaderDates(options);\n    var stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(options);\n    var tDateProfile = this.buildTimelineDateProfile(props.dateProfile, context.dateEnv, options, context.dateProfileGenerator);\n    var extraClassNames = ['fc-timeline', options.eventOverlap === false ? 'fc-timeline-overlap-disabled' : ''];\n    var slotMinWidth = options.slotMinWidth;\n    var slatCols = buildSlatCols(tDateProfile, slotMinWidth || this.computeFallbackSlotMinWidth(tDateProfile));\n    var sections = [{\n      type: 'header',\n      key: 'header',\n      isSticky: stickyHeaderDates,\n      chunks: [{\n        key: 'timeline',\n        content: function (contentArg) {\n          return createElement(TimelineHeader, {\n            dateProfile: props.dateProfile,\n            clientWidth: contentArg.clientWidth,\n            clientHeight: contentArg.clientHeight,\n            tableMinWidth: contentArg.tableMinWidth,\n            tableColGroupNode: contentArg.tableColGroupNode,\n            tDateProfile: tDateProfile,\n            slatCoords: state.slatCoords,\n            onMaxCushionWidth: slotMinWidth ? null : _this.handleMaxCushionWidth\n          });\n        }\n      }]\n    }, {\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      chunks: [{\n        key: 'timeline',\n        content: function (contentArg) {\n          return createElement(TimelineGrid, __assign({}, props, {\n            clientWidth: contentArg.clientWidth,\n            clientHeight: contentArg.clientHeight,\n            tableMinWidth: contentArg.tableMinWidth,\n            tableColGroupNode: contentArg.tableColGroupNode,\n            tDateProfile: tDateProfile,\n            onSlatCoords: _this.handleSlatCoords,\n            onScrollLeftRequest: _this.handleScrollLeftRequest\n          }));\n        }\n      }]\n    }];\n\n    if (stickyFooterScrollbar) {\n      sections.push({\n        type: 'footer',\n        key: 'footer',\n        isSticky: true,\n        chunks: [{\n          key: 'timeline',\n          content: renderScrollShim\n        }]\n      });\n    }\n\n    return createElement(ViewRoot, {\n      viewSpec: context.viewSpec\n    }, function (rootElRef, classNames) {\n      return createElement(\"div\", {\n        ref: rootElRef,\n        className: extraClassNames.concat(classNames).join(' ')\n      }, createElement(ScrollGrid, {\n        ref: _this.scrollGridRef,\n        liquid: !props.isHeightAuto && !props.forPrint,\n        collapsibleWidth: false,\n        colGroups: [{\n          cols: slatCols\n        }],\n        sections: sections\n      }));\n    });\n  };\n\n  TimelineView.prototype.computeFallbackSlotMinWidth = function (tDateProfile) {\n    return Math.max(30, (this.state.slotCushionMaxWidth || 0) / tDateProfile.slotsPerLabel);\n  };\n\n  return TimelineView;\n}(DateComponent);\n\nfunction buildSlatCols(tDateProfile, slotMinWidth) {\n  return [{\n    span: tDateProfile.slotCnt,\n    minWidth: slotMinWidth || 1 // needs to be a non-zero number to trigger horizontal scrollbars!??????\n\n  }];\n}\n\nvar main = createPlugin({\n  deps: [premiumCommonPlugin],\n  initialView: 'timelineDay',\n  views: {\n    timeline: {\n      component: TimelineView,\n      usesMinMaxTime: true,\n      eventResizableFromStart: true // how is this consumed for TimelineView tho?\n\n    },\n    timelineDay: {\n      type: 'timeline',\n      duration: {\n        days: 1\n      }\n    },\n    timelineWeek: {\n      type: 'timeline',\n      duration: {\n        weeks: 1\n      }\n    },\n    timelineMonth: {\n      type: 'timeline',\n      duration: {\n        months: 1\n      }\n    },\n    timelineYear: {\n      type: 'timeline',\n      duration: {\n        years: 1\n      }\n    }\n  }\n});\nexport default main;\nexport { TimelineCoords, TimelineHeader, TimelineHeaderRows, TimelineLane, TimelineLaneBg, TimelineLaneSlicer, TimelineSlats, TimelineView, buildSlatCols, buildTimelineDateProfile, coordToCss, coordsToCss };","map":{"version":3,"mappings":"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","names":["MIN_AUTO_LABELS","MAX_AUTO_SLOTS_PER_LABEL","MAX_AUTO_CELLS","config","MAX_TIMELINE_SLOTS","STOCK_SUB_DURATIONS","years","months","days","hours","minutes","seconds","milliseconds","buildTimelineDateProfile","dateProfile","dateEnv","allOptions","dateProfileGenerator","tDateProfile","labelInterval","slotLabelInterval","slotDuration","validateLabelAndSlot","ensureLabelInterval","ensureSlotDuration","input","slotLabelFormat","rawFormats","Array","isArray","computeHeaderFormats","headerFormats","map","rawFormat","isTimeScale","Boolean","largeUnit","slotUnit","greatestDurationDenominator","unit","test","emphasizeWeeks","asCleanDays","currentRangeAs","businessHours","rawSnapDuration","snapDuration","snapsPerSlot","createDuration","wholeDivideDurations","timeWindowMs","asRoughMs","slotMaxTime","slotMinTime","normalizedStart","normalizeDate","renderRange","start","normalizedEnd","end","add","addDays","normalizedRange","slotDates","date","isValidDate","push","snapIndex","snapDiff","snapDiffToIndex","snapIndexToDiff","snapCnt","slotCnt","isWeekStarts","buildIsWeekStarts","cellRows","buildCellRows","slotsPerLabel","normalDate","startOfDay","startOf","normalizeRange","range","computeVisibleDayRange","dayRange","valueOf","isHiddenDay","day","timeMs","ms","labelCnt","countDurationsBetween","currentRange","console","warn","_i","tryLabelInterval","_a","trySlotDuration","format1","format2","weekNumbersVisible","weekNumbers","format0","year","month","week","weekday","omitCommas","hour","minute","omitZeroMinute","meridiem","asRoughMinutes","params","padStart","asRoughSeconds","second","millisecond","concat","res","diffWholeYears","diffWholeMonths","diffWholeDays","prevWeekNumber","slotDate","weekNumber","computeWeekNumber","isWeekStart","formats","slotAsDays","guessedSlotUnit","rowUnitsFromFormats","format","getLargestUnit","i","length","row","rowCells","leadingCell","isLastRow","isSuperRow","newCell","rowUnit","text","buildCellObject","colspan","isInt","weekStart","__extends","TimelineHeaderThInner","props","context","createElement","ContentHook","hookProps","content","options","slotLabelContent","defaultContent","renderInnerContent","innerElRef","innerContent","ref","className","isSticky","navLinkAttrs","BaseComponent","refineHookProps","level","toDate","dateMarker","view","viewApi","_this","memoizeObjArg","buildClassNameNormalizer","memoize","buildCellNavLinkAttrs","TimelineHeaderTh","dateMeta","getDateMeta","cell","todayRange","nowDate","classNames","getSlotClassNames","theme","getDayClassNames","rowLevel","customClassNames","normalizeClassNames","slotLabelClassNames","MountHook","didMount","slotLabelDidMount","willUnmount","slotLabelWillUnmount","rootElRef","join","formatIso","omitTime","omitTimeZoneOffset","colSpan","style","height","rowInnerHeight","cellDate","buildNavLinkAttrs","TimelineHeaderRows","rowInnerHeights","Fragment","isLast","isChrono","key","toISOString","slatRootEl","slatEls","isRtl","outerCoordCache","PositionCache","innerCoordCache","findDirectChildren","TimelineCoords","rangeContainsMarker","snapCoverage","computeDateSnapCoverage","slotCoverage","slotIndex","Math","floor","min","partial","originClientRect","width","rights","getWidth","lefts","dateToCoord","duration","coord","activeRange","snapDiffInt","ceil","coordToCss","hcoord","left","right","coordsToCss","hcoords","createRef","TimelineHeader","timerUnit","slatCoords","NowTimer","minWidth","tableMinWidth","clientWidth","tableColGroupNode","nowIndicator","isDateInRange","NowIndicatorRoot","isAxis","updateSize","onMaxCushionWidth","computeMaxCushionWidth","max","apply","findElements","current","el","getBoundingClientRect","TimelineSlatCell","isEm","dataAttrs","isDay","RenderHook","slotLaneClassNames","slotLaneContent","slotLaneDidMount","slotLaneWillUnmount","elRef","TimelineSlatsBody","cellElRefs","RefMap","request","onScrollLeftRequest","coords","time","scrollLeft","coordFromLeft","durationToCoord","TimelineSlats","getClass","updateSizing","scrollResponder","createScrollResponder","handleScrollRequest","prevProps","update","detach","onCoords","rootEl","offsetWidth","collectCellEls","currentMap","leftPosition","slatIndex","leftToIndex","slatWidth","localSnapIndex","multiplyDuration","dateSpan","allDay","dayEl","elMap","computeSegHCoords","segs","timelineCoords","seg","rangeToCoords","round","computeFgSegPlacements","segHCoords","eventInstanceHeights","moreLinkHeights","strictOrder","maxStackCnt","segInputs","crudePlacements","instanceId","eventRange","instance","index","span","thickness","top","hierarchy","SegHierarchy","hiddenEntries","addSegs","hiddenPlacements","entry","hiddenGroups","groupIntersectingEntries","moreLinkInputs","moreLinkCrudePlacements","extractSeg","hiddenGroup","sortedSegs","entries","buildIsoString","computeEarliestSegStart","visibleRects","toRects","visiblePlacements","maxHeight","rect","segIndex","levelCoord","TimelineLaneBg","highlightSeg","eventResizeSegs","dateSelectionSegs","renderSegs","businessHourSegs","bgEventSegs","fillType","children","hStyle","buildEventRangeKey","BgEvent","__assign","getSegMeta","renderFill","TimelineLaneSlicer","origRange","normalRange","slicedRange","intersectRanges","isStart","isEnd","addMs","Slicer","DEFAULT_TIME_FORMAT","createFormatter","TimelineEvent","StandardEvent","extraClassNames","defaultTimeFormat","defaultDisplayEventTime","TimelineLaneMoreLink","placement","resourceId","isVisible","extraDateSpan","MoreLinkRoot","allDayDate","moreCnt","hiddenSegs","allSegs","alignmentElRef","popoverContent","visibility","isForcedInvisible","isDragging","isResizing","isDateSelecting","isSelected","eventSelection","handleClick","title","isExpanded","popoverId","setRef","onClick","sortEventSegs","TimelineLane","state","slicedProps","slicer","sliceProps","nextDayThreshold","mirrorSegs","eventDrag","eventResize","fgSegs","fgEventSegs","eventOrder","fgSegHCoords","eventMinWidth","eventOrderStrict","eventMaxStack","fgPlacements","fgHeight","affectedInstances","renderFgSegs","buildMirrorPlacements","prevState","eventStore","onHeightChange","setState","mapHash","harnessElRefs","harnessEl","moreElRefs","moreEl","segPlacements","isMirror","segPlacement","isoStr","addStateEquality","isPropsEqual","topsByInstanceId","buildAbsoluteTopHash","placements","registerInteractiveComponent","unregisterInteractiveComponent","onSlatCoords","TimelineGrid","handeEl","clientHeight","slatsRef","handleCoords","eventUiBases","dateSelection","positionLeft","positionTop","elWidth","elHeight","slats","slatHit","positionToHit","bottom","layer","DateComponent","slotCushionMaxWidth","scrollGrid","scrollGridRef","forceScrollLeft","TimelineView","stickyHeaderDates","forPrint","getStickyHeaderDates","stickyFooterScrollbar","getStickyFooterScrollbar","eventOverlap","slatCols","buildSlatCols","slotMinWidth","computeFallbackSlotMinWidth","sections","type","chunks","contentArg","handleMaxCushionWidth","liquid","handleSlatCoords","handleScrollLeftRequest","renderScrollShim","ViewRoot","viewSpec","ScrollGrid","isHeightAuto","collapsibleWidth","colGroups","cols","createPlugin","deps","premiumCommonPlugin","initialView","views","timeline","component","usesMinMaxTime","eventResizableFromStart","timelineDay","timelineWeek","weeks","timelineMonth","timelineYear"],"sources":["src/timeline-date-profile.ts","src/TimelineHeaderThInner.tsx","src/TimelineHeaderTh.tsx","src/TimelineHeaderRows.tsx","src/TimelineCoords.ts","src/TimelineHeader.tsx","src/TimelineSlatCell.tsx","src/TimelineSlatsBody.tsx","src/TimelineSlats.tsx","src/event-placement.ts","src/TimelineLaneBg.tsx","src/TimelineLaneSlicer.ts","src/TimelineEvent.tsx","src/TimelineLaneMoreLink.tsx","src/TimelineLane.tsx","src/TimelineGrid.tsx","src/TimelineView.tsx","src/main.ts"],"sourcesContent":["import {\n  config, computeVisibleDayRange, Duration, DateProfile, asCleanDays, addDays, wholeDivideDurations, DateMarker,\n  startOfDay, createDuration, DateEnv, diffWholeDays, asRoughMs, createFormatter, greatestDurationDenominator,\n  asRoughMinutes, padStart, asRoughSeconds, DateRange, isInt, DateProfileGenerator, BaseOptionsRefined,\n} from '@fullcalendar/common'\n\nexport interface TimelineDateProfile {\n  labelInterval: Duration\n  slotDuration: Duration\n  slotsPerLabel: number\n  headerFormats: any\n  isTimeScale: boolean\n  largeUnit: string\n  emphasizeWeeks: boolean\n  snapDuration: Duration\n  snapsPerSlot: number\n  normalizedRange: DateRange // snaps to unit. adds in slotMinTime/slotMaxTime\n  timeWindowMs: number\n  slotDates: DateMarker[]\n  isWeekStarts: boolean[]\n  snapDiffToIndex: number[]\n  snapIndexToDiff: number[]\n  snapCnt: number\n  slotCnt: number\n  cellRows: TimelineHeaderCell[][]\n}\n\nexport interface TimelineHeaderCell {\n  date: DateMarker\n  text: string\n  rowUnit: string\n  colspan: number\n  isWeekStart: boolean\n}\n\nconst MIN_AUTO_LABELS = 18 // more than `12` months but less that `24` hours\nconst MAX_AUTO_SLOTS_PER_LABEL = 6 // allows 6 10-min slots in an hour\nconst MAX_AUTO_CELLS = 200 // allows 4-days to have a :30 slot duration\nconfig.MAX_TIMELINE_SLOTS = 1000\n\n// potential nice values for slot-duration and interval-duration\nconst STOCK_SUB_DURATIONS = [ // from largest to smallest\n  { years: 1 },\n  { months: 1 },\n  { days: 1 },\n  { hours: 1 },\n  { minutes: 30 },\n  { minutes: 15 },\n  { minutes: 10 },\n  { minutes: 5 },\n  { minutes: 1 },\n  { seconds: 30 },\n  { seconds: 15 },\n  { seconds: 10 },\n  { seconds: 5 },\n  { seconds: 1 },\n  { milliseconds: 500 },\n  { milliseconds: 100 },\n  { milliseconds: 10 },\n  { milliseconds: 1 },\n]\n\nexport function buildTimelineDateProfile(\n  dateProfile: DateProfile,\n  dateEnv: DateEnv,\n  allOptions: BaseOptionsRefined,\n  dateProfileGenerator: DateProfileGenerator,\n): TimelineDateProfile {\n  let tDateProfile = {\n    labelInterval: allOptions.slotLabelInterval,\n    slotDuration: allOptions.slotDuration,\n  } as TimelineDateProfile\n\n  validateLabelAndSlot(tDateProfile, dateProfile, dateEnv) // validate after computed grid duration\n  ensureLabelInterval(tDateProfile, dateProfile, dateEnv)\n  ensureSlotDuration(tDateProfile, dateProfile, dateEnv)\n\n  let input = allOptions.slotLabelFormat\n  let rawFormats =\n    Array.isArray(input) ? input :\n      (input != null) ? [input] :\n        computeHeaderFormats(tDateProfile, dateProfile, dateEnv, allOptions)\n\n  tDateProfile.headerFormats = rawFormats.map((rawFormat) => createFormatter(rawFormat))\n\n  tDateProfile.isTimeScale = Boolean(tDateProfile.slotDuration.milliseconds)\n\n  let largeUnit = null\n  if (!tDateProfile.isTimeScale) {\n    const slotUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit\n    if (/year|month|week/.test(slotUnit)) {\n      largeUnit = slotUnit\n    }\n  }\n\n  tDateProfile.largeUnit = largeUnit\n\n  tDateProfile.emphasizeWeeks =\n    asCleanDays(tDateProfile.slotDuration) === 1 &&\n    currentRangeAs('weeks', dateProfile, dateEnv) >= 2 &&\n    !allOptions.businessHours\n\n  /*\n  console.log('label interval =', timelineView.labelInterval.humanize())\n  console.log('slot duration =', timelineView.slotDuration.humanize())\n  console.log('header formats =', timelineView.headerFormats)\n  console.log('isTimeScale', timelineView.isTimeScale)\n  console.log('largeUnit', timelineView.largeUnit)\n  */\n\n  let rawSnapDuration = allOptions.snapDuration\n  let snapDuration\n  let snapsPerSlot\n\n  if (rawSnapDuration) {\n    snapDuration = createDuration(rawSnapDuration)\n    snapsPerSlot = wholeDivideDurations(tDateProfile.slotDuration, snapDuration)\n    // ^ TODO: warning if not whole?\n  }\n\n  if (snapsPerSlot == null) {\n    snapDuration = tDateProfile.slotDuration\n    snapsPerSlot = 1\n  }\n\n  tDateProfile.snapDuration = snapDuration\n  tDateProfile.snapsPerSlot = snapsPerSlot\n\n  // more...\n\n  let timeWindowMs = asRoughMs(dateProfile.slotMaxTime) - asRoughMs(dateProfile.slotMinTime)\n\n  // TODO: why not use normalizeRange!?\n  let normalizedStart = normalizeDate(dateProfile.renderRange.start, tDateProfile, dateEnv)\n  let normalizedEnd = normalizeDate(dateProfile.renderRange.end, tDateProfile, dateEnv)\n\n  // apply slotMinTime/slotMaxTime\n  // TODO: View should be responsible.\n  if (tDateProfile.isTimeScale) {\n    normalizedStart = dateEnv.add(normalizedStart, dateProfile.slotMinTime)\n    normalizedEnd = dateEnv.add(\n      addDays(normalizedEnd, -1),\n      dateProfile.slotMaxTime,\n    )\n  }\n\n  tDateProfile.timeWindowMs = timeWindowMs\n  tDateProfile.normalizedRange = { start: normalizedStart, end: normalizedEnd }\n\n  let slotDates = []\n  let date = normalizedStart\n  while (date < normalizedEnd) {\n    if (isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator)) {\n      slotDates.push(date)\n    }\n    date = dateEnv.add(date, tDateProfile.slotDuration)\n  }\n\n  tDateProfile.slotDates = slotDates\n\n  // more...\n\n  let snapIndex = -1\n  let snapDiff = 0 // index of the diff :(\n  const snapDiffToIndex = []\n  const snapIndexToDiff = []\n\n  date = normalizedStart\n  while (date < normalizedEnd) {\n    if (isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator)) {\n      snapIndex += 1\n      snapDiffToIndex.push(snapIndex)\n      snapIndexToDiff.push(snapDiff)\n    } else {\n      snapDiffToIndex.push(snapIndex + 0.5)\n    }\n    date = dateEnv.add(date, tDateProfile.snapDuration)\n    snapDiff += 1\n  }\n\n  tDateProfile.snapDiffToIndex = snapDiffToIndex\n  tDateProfile.snapIndexToDiff = snapIndexToDiff\n\n  tDateProfile.snapCnt = snapIndex + 1 // is always one behind\n  tDateProfile.slotCnt = tDateProfile.snapCnt / tDateProfile.snapsPerSlot\n\n  // more...\n\n  tDateProfile.isWeekStarts = buildIsWeekStarts(tDateProfile, dateEnv)\n  tDateProfile.cellRows = buildCellRows(tDateProfile, dateEnv)\n  tDateProfile.slotsPerLabel = wholeDivideDurations(tDateProfile.labelInterval, tDateProfile.slotDuration)\n\n  return tDateProfile\n}\n\n/*\nsnaps to appropriate unit\n*/\nexport function normalizeDate(date: DateMarker, tDateProfile: TimelineDateProfile, dateEnv: DateEnv): DateMarker {\n  let normalDate = date\n\n  if (!tDateProfile.isTimeScale) {\n    normalDate = startOfDay(normalDate)\n\n    if (tDateProfile.largeUnit) {\n      normalDate = dateEnv.startOf(normalDate, tDateProfile.largeUnit)\n    }\n  }\n\n  return normalDate\n}\n\n/*\nsnaps to appropriate unit\n*/\nexport function normalizeRange(range: DateRange, tDateProfile: TimelineDateProfile, dateEnv: DateEnv): DateRange {\n  if (!tDateProfile.isTimeScale) {\n    range = computeVisibleDayRange(range)\n\n    if (tDateProfile.largeUnit) {\n      let dayRange = range // preserve original result\n\n      range = {\n        start: dateEnv.startOf(range.start, tDateProfile.largeUnit),\n        end: dateEnv.startOf(range.end, tDateProfile.largeUnit),\n      }\n\n      // if date is partially through the interval, or is in the same interval as the start,\n      // make the exclusive end be the *next* interval\n      if (range.end.valueOf() !== dayRange.end.valueOf() || range.end <= range.start) {\n        range = {\n          start: range.start,\n          end: dateEnv.add(range.end, tDateProfile.slotDuration),\n        }\n      }\n    }\n  }\n\n  return range\n}\n\nexport function isValidDate(\n  date: DateMarker,\n  tDateProfile: TimelineDateProfile,\n  dateProfile: DateProfile,\n  dateProfileGenerator: DateProfileGenerator,\n) {\n  if (dateProfileGenerator.isHiddenDay(date)) {\n    return false\n  }\n\n  if (tDateProfile.isTimeScale) {\n    // determine if the time is within slotMinTime/slotMaxTime, which may have wacky values\n    let day = startOfDay(date)\n    let timeMs = date.valueOf() - day.valueOf()\n    let ms = timeMs - asRoughMs(dateProfile.slotMinTime) // milliseconds since slotMinTime\n    ms = ((ms % 86400000) + 86400000) % 86400000 // make negative values wrap to 24hr clock\n    return ms < tDateProfile.timeWindowMs // before the slotMaxTime?\n  }\n\n  return true\n}\n\nfunction validateLabelAndSlot(tDateProfile: TimelineDateProfile, dateProfile: DateProfile, dateEnv: DateEnv) {\n  const { currentRange } = dateProfile\n\n  // make sure labelInterval doesn't exceed the max number of cells\n  if (tDateProfile.labelInterval) {\n    const labelCnt = dateEnv.countDurationsBetween(\n      currentRange.start,\n      currentRange.end,\n      tDateProfile.labelInterval,\n    )\n    if (labelCnt > config.MAX_TIMELINE_SLOTS) {\n      console.warn('slotLabelInterval results in too many cells')\n      tDateProfile.labelInterval = null\n    }\n  }\n\n  // make sure slotDuration doesn't exceed the maximum number of cells\n  if (tDateProfile.slotDuration) {\n    const slotCnt = dateEnv.countDurationsBetween(\n      currentRange.start,\n      currentRange.end,\n      tDateProfile.slotDuration,\n    )\n    if (slotCnt > config.MAX_TIMELINE_SLOTS) {\n      console.warn('slotDuration results in too many cells')\n      tDateProfile.slotDuration = null\n    }\n  }\n\n  // make sure labelInterval is a multiple of slotDuration\n  if (tDateProfile.labelInterval && tDateProfile.slotDuration) {\n    const slotsPerLabel = wholeDivideDurations(tDateProfile.labelInterval, tDateProfile.slotDuration)\n    if (slotsPerLabel === null || slotsPerLabel < 1) {\n      console.warn('slotLabelInterval must be a multiple of slotDuration')\n      tDateProfile.slotDuration = null\n    }\n  }\n}\n\nfunction ensureLabelInterval(tDateProfile: TimelineDateProfile, dateProfile: DateProfile, dateEnv: DateEnv) {\n  const { currentRange } = dateProfile\n  let { labelInterval } = tDateProfile\n\n  if (!labelInterval) {\n    // compute based off the slot duration\n    // find the largest label interval with an acceptable slots-per-label\n    let input\n    if (tDateProfile.slotDuration) {\n      for (input of STOCK_SUB_DURATIONS) {\n        const tryLabelInterval = createDuration(input)\n        const slotsPerLabel = wholeDivideDurations(tryLabelInterval, tDateProfile.slotDuration)\n        if (slotsPerLabel !== null && slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL) {\n          labelInterval = tryLabelInterval\n          break\n        }\n      }\n\n      // use the slot duration as a last resort\n      if (!labelInterval) {\n        labelInterval = tDateProfile.slotDuration\n      }\n\n    // compute based off the view's duration\n    // find the largest label interval that yields the minimum number of labels\n    } else {\n      for (input of STOCK_SUB_DURATIONS) {\n        labelInterval = createDuration(input)\n        const labelCnt = dateEnv.countDurationsBetween(\n          currentRange.start,\n          currentRange.end,\n          labelInterval,\n        )\n        if (labelCnt >= MIN_AUTO_LABELS) {\n          break\n        }\n      }\n    }\n\n    tDateProfile.labelInterval = labelInterval\n  }\n\n  return labelInterval\n}\n\nfunction ensureSlotDuration(tDateProfile: TimelineDateProfile, dateProfile: DateProfile, dateEnv: DateEnv) {\n  const { currentRange } = dateProfile\n  let { slotDuration } = tDateProfile\n\n  if (!slotDuration) {\n    const labelInterval = ensureLabelInterval(tDateProfile, dateProfile, dateEnv) // will compute if necessary\n\n    // compute based off the label interval\n    // find the largest slot duration that is different from labelInterval, but still acceptable\n    for (let input of STOCK_SUB_DURATIONS) {\n      const trySlotDuration = createDuration(input)\n      const slotsPerLabel = wholeDivideDurations(labelInterval, trySlotDuration)\n      if (slotsPerLabel !== null && slotsPerLabel > 1 && slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL) {\n        slotDuration = trySlotDuration\n        break\n      }\n    }\n\n    // only allow the value if it won't exceed the view's # of slots limit\n    if (slotDuration) {\n      const slotCnt = dateEnv.countDurationsBetween(\n        currentRange.start,\n        currentRange.end,\n        slotDuration,\n      )\n      if (slotCnt > MAX_AUTO_CELLS) {\n        slotDuration = null\n      }\n    }\n\n    // use the label interval as a last resort\n    if (!slotDuration) {\n      slotDuration = labelInterval\n    }\n\n    tDateProfile.slotDuration = slotDuration\n  }\n\n  return slotDuration\n}\n\nfunction computeHeaderFormats(\n  tDateProfile: TimelineDateProfile,\n  dateProfile: DateProfile,\n  dateEnv: DateEnv,\n  allOptions: BaseOptionsRefined,\n) {\n  let format1\n  let format2\n  const { labelInterval } = tDateProfile\n  let unit = greatestDurationDenominator(labelInterval).unit\n  const weekNumbersVisible = allOptions.weekNumbers\n  let format0 = (format1 = (format2 = null))\n\n  // NOTE: weekNumber computation function wont work\n\n  if ((unit === 'week') && !weekNumbersVisible) {\n    unit = 'day'\n  }\n\n  switch (unit) {\n    case 'year':\n      format0 = { year: 'numeric' } // '2015'\n      break\n\n    case 'month':\n      if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n        format0 = { year: 'numeric' } // '2015'\n      }\n\n      format1 = { month: 'short' } // 'Jan'\n      break\n\n    case 'week':\n      if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n        format0 = { year: 'numeric' } // '2015'\n      }\n\n      format1 = { week: 'narrow' } // 'Wk4'\n      break\n\n    case 'day':\n      if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n        format0 = { year: 'numeric', month: 'long' } // 'January 2014'\n      } else if (currentRangeAs('months', dateProfile, dateEnv) > 1) {\n        format0 = { month: 'long' } // 'January'\n      }\n\n      if (weekNumbersVisible) {\n        format1 = { week: 'short' } // 'Wk 4'\n      }\n\n      format2 = { weekday: 'narrow', day: 'numeric' } // 'Su 9'\n      break\n\n    case 'hour':\n      if (weekNumbersVisible) {\n        format0 = { week: 'short' } // 'Wk 4'\n      }\n\n      if (currentRangeAs('days', dateProfile, dateEnv) > 1) {\n        format1 = { weekday: 'short', day: 'numeric', month: 'numeric', omitCommas: true } // Sat 4/7\n      }\n\n      format2 = {\n        hour: 'numeric',\n        minute: '2-digit',\n        omitZeroMinute: true,\n        meridiem: 'short',\n      }\n      break\n\n    case 'minute':\n      // sufficiently large number of different minute cells?\n      if ((asRoughMinutes(labelInterval) / 60) >= MAX_AUTO_SLOTS_PER_LABEL) {\n        format0 = {\n          hour: 'numeric',\n          meridiem: 'short',\n        }\n        format1 = (params) => (\n          ':' + padStart(params.date.minute, 2) // ':30'\n        )\n      } else {\n        format0 = {\n          hour: 'numeric',\n          minute: 'numeric',\n          meridiem: 'short',\n        }\n      }\n      break\n\n    case 'second':\n      // sufficiently large number of different second cells?\n      if ((asRoughSeconds(labelInterval) / 60) >= MAX_AUTO_SLOTS_PER_LABEL) {\n        format0 = { hour: 'numeric', minute: '2-digit', meridiem: 'lowercase' } // '8:30 PM'\n        format1 = (params) => (\n          ':' + padStart(params.date.second, 2) // ':30'\n        )\n      } else {\n        format0 = { hour: 'numeric', minute: '2-digit', second: '2-digit', meridiem: 'lowercase' } // '8:30:45 PM'\n      }\n      break\n\n    case 'millisecond':\n      format0 = { hour: 'numeric', minute: '2-digit', second: '2-digit', meridiem: 'lowercase' } // '8:30:45 PM'\n      format1 = (params) => (\n        '.' + padStart(params.millisecond, 3)\n      )\n      break\n  }\n\n  return [].concat(format0 || [], format1 || [], format2 || [])\n}\n\n// Compute the number of the give units in the \"current\" range.\n// Won't go more precise than days.\n// Will return `0` if there's not a clean whole interval.\nfunction currentRangeAs(unit: string, dateProfile: DateProfile, dateEnv: DateEnv) {\n  let range = dateProfile.currentRange\n  let res = null\n\n  if (unit === 'years') {\n    res = dateEnv.diffWholeYears(range.start, range.end)\n  } else if (unit === 'months') {\n    res = dateEnv.diffWholeMonths(range.start, range.end)\n  } else if (unit === 'weeks') {\n    res = dateEnv.diffWholeMonths(range.start, range.end)\n  } else if (unit === 'days') {\n    res = diffWholeDays(range.start, range.end)\n  }\n\n  return res || 0\n}\n\nfunction buildIsWeekStarts(tDateProfile: TimelineDateProfile, dateEnv: DateEnv) {\n  let { slotDates, emphasizeWeeks } = tDateProfile\n  let prevWeekNumber = null\n  let isWeekStarts: boolean[] = []\n\n  for (let slotDate of slotDates) {\n    let weekNumber = dateEnv.computeWeekNumber(slotDate)\n    let isWeekStart = emphasizeWeeks && (prevWeekNumber !== null) && (prevWeekNumber !== weekNumber)\n    prevWeekNumber = weekNumber\n\n    isWeekStarts.push(isWeekStart)\n  }\n\n  return isWeekStarts\n}\n\nfunction buildCellRows(tDateProfile: TimelineDateProfile, dateEnv: DateEnv) {\n  let slotDates = tDateProfile.slotDates\n  let formats = tDateProfile.headerFormats\n  let cellRows = formats.map(() => []) // indexed by row,col\n  let slotAsDays = asCleanDays(tDateProfile.slotDuration)\n  let guessedSlotUnit =\n    slotAsDays === 7 ? 'week' :\n      slotAsDays === 1 ? 'day' :\n        null\n\n  // specifically for navclicks\n  let rowUnitsFromFormats = formats.map(\n    (format) => (format.getLargestUnit ? format.getLargestUnit() : null),\n  )\n\n  // builds cellRows and slotCells\n  for (let i = 0; i < slotDates.length; i += 1) {\n    let date = slotDates[i]\n    let isWeekStart = tDateProfile.isWeekStarts[i]\n\n    for (let row = 0; row < formats.length; row += 1) {\n      let format = formats[row]\n      let rowCells = cellRows[row]\n      let leadingCell = rowCells[rowCells.length - 1]\n      let isLastRow = row === formats.length - 1\n      let isSuperRow = formats.length > 1 && !isLastRow // more than one row and not the last\n      let newCell = null\n      let rowUnit = rowUnitsFromFormats[row] || (isLastRow ? guessedSlotUnit : null)\n\n      if (isSuperRow) {\n        let text = dateEnv.format(date, format)\n        if (!leadingCell || (leadingCell.text !== text)) {\n          newCell = buildCellObject(date, text, rowUnit)\n        } else {\n          leadingCell.colspan += 1\n        }\n      } else if (\n        !leadingCell ||\n        isInt(dateEnv.countDurationsBetween(\n          tDateProfile.normalizedRange.start,\n          date,\n          tDateProfile.labelInterval,\n        ))\n      ) {\n        let text = dateEnv.format(date, format)\n        newCell = buildCellObject(date, text, rowUnit)\n      } else {\n        leadingCell.colspan += 1\n      }\n\n      if (newCell) {\n        newCell.weekStart = isWeekStart\n        rowCells.push(newCell)\n      }\n    }\n  }\n\n  return cellRows\n}\n\nfunction buildCellObject(date: DateMarker, text, rowUnit): TimelineHeaderCell {\n  return { date, text, rowUnit, colspan: 1, isWeekStart: false }\n}\n","import { createElement, BaseComponent, DateMarker, ContentHook, ViewApi, DateEnv } from '@fullcalendar/common'\n\nexport interface TimelineHeaderThInnerProps {\n  hookProps: HookProps\n  isSticky: boolean\n  navLinkAttrs: object | null\n}\n\nexport class TimelineHeaderThInner extends BaseComponent<TimelineHeaderThInnerProps> {\n  render() {\n    let { props, context } = this\n\n    return (\n      <ContentHook hookProps={props.hookProps} content={context.options.slotLabelContent} defaultContent={renderInnerContent}>\n        {(innerElRef, innerContent) => (\n          <a\n            ref={innerElRef}\n            className={'fc-timeline-slot-cushion fc-scrollgrid-sync-inner' + (props.isSticky ? ' fc-sticky' : '')}\n            {...props.navLinkAttrs}\n          >\n            {innerContent}\n          </a>\n        )}\n      </ContentHook>\n    )\n  }\n}\n\nfunction renderInnerContent(props) { // TODO: add types\n  return props.text\n}\n\n// hook props\n// ----------\n\nexport interface HookPropsInput {\n  level: number\n  dateMarker: DateMarker\n  text: string\n  dateEnv: DateEnv\n  viewApi: ViewApi\n}\n\nexport interface HookProps {\n  level: number\n  date: DateMarker // localized\n  view: ViewApi\n  text: string\n}\n\nexport function refineHookProps(input: HookPropsInput): HookProps {\n  return {\n    level: input.level,\n    date: input.dateEnv.toDate(input.dateMarker),\n    view: input.viewApi,\n    text: input.text,\n  }\n}\n","import {\n  createElement, BaseComponent, DateRange, DateMarker, getDateMeta, getSlotClassNames,\n  buildNavLinkAttrs, buildClassNameNormalizer, MountHook,\n  getDayClassNames, DateProfile, memoizeObjArg, ViewContext, memoize,\n} from '@fullcalendar/common'\nimport { TimelineDateProfile, TimelineHeaderCell } from './timeline-date-profile'\nimport { TimelineHeaderThInner, refineHookProps, HookProps } from './TimelineHeaderThInner'\n\nexport interface TimelineHeaderThProps {\n  dateProfile: DateProfile\n  tDateProfile: TimelineDateProfile\n  rowLevel: number\n  cell: TimelineHeaderCell\n  todayRange: DateRange\n  nowDate: DateMarker\n  rowInnerHeight?: number\n  isSticky: boolean\n}\n\nexport class TimelineHeaderTh extends BaseComponent<TimelineHeaderThProps> {\n  refineHookProps = memoizeObjArg(refineHookProps)\n  normalizeClassNames = buildClassNameNormalizer<HookProps>()\n  buildCellNavLinkAttrs = memoize(buildCellNavLinkAttrs)\n\n  render() {\n    let { props, context } = this\n    let { dateEnv, options } = context\n    let { cell, dateProfile, tDateProfile } = props\n\n    // the cell.rowUnit is f'd\n    // giving 'month' for a 3-day view\n    // workaround: to infer day, do NOT time\n\n    let dateMeta = getDateMeta(cell.date, props.todayRange, props.nowDate, dateProfile)\n\n    let classNames = ['fc-timeline-slot', 'fc-timeline-slot-label'].concat(\n      cell.rowUnit === 'time' // TODO: so slot classnames for week/month/bigger. see note above about rowUnit\n        ? getSlotClassNames(dateMeta, context.theme)\n        : getDayClassNames(dateMeta, context.theme),\n    )\n\n    if (cell.isWeekStart) {\n      classNames.push('fc-timeline-slot-em')\n    }\n\n    let hookProps = this.refineHookProps({\n      level: props.rowLevel,\n      dateMarker: cell.date,\n      text: cell.text,\n      dateEnv: context.dateEnv,\n      viewApi: context.viewApi,\n    })\n\n    let customClassNames = this.normalizeClassNames(options.slotLabelClassNames, hookProps)\n\n    return (\n      <MountHook hookProps={hookProps} didMount={options.slotLabelDidMount} willUnmount={options.slotLabelWillUnmount}>\n        {(rootElRef) => (\n          <th\n            ref={rootElRef}\n            className={classNames.concat(customClassNames).join(' ')}\n            data-date={dateEnv.formatIso(cell.date, { omitTime: !tDateProfile.isTimeScale, omitTimeZoneOffset: true })}\n            colSpan={cell.colspan}\n          >\n            <div className=\"fc-timeline-slot-frame\" style={{ height: props.rowInnerHeight }}>\n              <TimelineHeaderThInner\n                hookProps={hookProps}\n                isSticky={props.isSticky}\n                navLinkAttrs={this.buildCellNavLinkAttrs(context, cell.date, cell.rowUnit)}\n              />\n            </div>\n          </th>\n        )}\n      </MountHook>\n    )\n  }\n}\n\nfunction buildCellNavLinkAttrs(context: ViewContext, cellDate: DateMarker, rowUnit: string): object {\n  return (rowUnit && rowUnit !== 'time')\n    ? buildNavLinkAttrs(context, cellDate, rowUnit)\n    : {}\n}\n","import { createElement, BaseComponent, Fragment, DateRange, DateMarker, DateProfile } from '@fullcalendar/common'\nimport { TimelineDateProfile } from './timeline-date-profile'\nimport { TimelineHeaderTh } from './TimelineHeaderTh'\n\nexport interface TimelineHeaderRowsProps {\n  dateProfile: DateProfile\n  tDateProfile: TimelineDateProfile\n  nowDate: DateMarker\n  todayRange: DateRange\n  rowInnerHeights?: number[]\n}\n\nexport class TimelineHeaderRows extends BaseComponent<TimelineHeaderRowsProps> {\n  render() {\n    let { dateProfile, tDateProfile, rowInnerHeights, todayRange, nowDate } = this.props\n    let { cellRows } = tDateProfile\n\n    return (\n      <Fragment>\n        {cellRows.map((rowCells, rowLevel) => {\n          let isLast = rowLevel === cellRows.length - 1\n          let isChrono = tDateProfile.isTimeScale && isLast // the final row, with times?\n          let classNames = [\n            'fc-timeline-header-row',\n            isChrono ? 'fc-timeline-header-row-chrono' : '',\n          ]\n\n          return ( // eslint-disable-next-line react/no-array-index-key\n            <tr key={rowLevel} className={classNames.join(' ')}>\n              {rowCells.map((cell) => (\n                <TimelineHeaderTh\n                  key={cell.date.toISOString()}\n                  cell={cell}\n                  rowLevel={rowLevel}\n                  dateProfile={dateProfile}\n                  tDateProfile={tDateProfile}\n                  todayRange={todayRange}\n                  nowDate={nowDate}\n                  rowInnerHeight={rowInnerHeights && rowInnerHeights[rowLevel]}\n                  isSticky={!isLast}\n                />\n              ))}\n            </tr>\n          )\n        })}\n      </Fragment>\n    )\n  }\n}\n","import {\n  PositionCache, findDirectChildren,\n  isInt, DateProfile,\n  DateMarker, DateEnv, Duration, startOfDay, rangeContainsMarker, CssDimValue, DateRange, SegSpan,\n} from '@fullcalendar/common'\nimport { TimelineDateProfile } from './timeline-date-profile'\n\nexport class TimelineCoords { // TODO: rename to \"slat\" coords?\n  outerCoordCache: PositionCache\n  innerCoordCache: PositionCache\n\n  constructor(\n    public slatRootEl: HTMLElement, // okay to expose?\n    slatEls: HTMLElement[],\n    public dateProfile: DateProfile,\n    private tDateProfile: TimelineDateProfile,\n    private dateEnv: DateEnv,\n    public isRtl: boolean,\n  ) {\n    this.outerCoordCache = new PositionCache(\n      slatRootEl,\n      slatEls,\n      true, // isHorizontal\n      false, // isVertical\n    )\n\n    // for the inner divs within the slats\n    // used for event rendering and scrollTime, to disregard slat border\n    this.innerCoordCache = new PositionCache(\n      slatRootEl,\n      findDirectChildren(slatEls, 'div'),\n      true, // isHorizontal\n      false, // isVertical\n    )\n  }\n\n  isDateInRange(date: DateMarker) {\n    return rangeContainsMarker(this.dateProfile.currentRange, date)\n  }\n\n  // results range from negative width of area to 0\n  dateToCoord(date: DateMarker): number {\n    let { tDateProfile } = this\n    let snapCoverage = this.computeDateSnapCoverage(date)\n    let slotCoverage = snapCoverage / tDateProfile.snapsPerSlot\n    let slotIndex = Math.floor(slotCoverage)\n    slotIndex = Math.min(slotIndex, tDateProfile.slotCnt - 1)\n    let partial = slotCoverage - slotIndex\n    let { innerCoordCache, outerCoordCache } = this\n\n    if (this.isRtl) {\n      return outerCoordCache.originClientRect.width - (\n        outerCoordCache.rights[slotIndex] -\n        (innerCoordCache.getWidth(slotIndex) * partial)\n      )\n    }\n\n    return (\n      outerCoordCache.lefts[slotIndex] +\n      (innerCoordCache.getWidth(slotIndex) * partial)\n    )\n  }\n\n  rangeToCoords(range: DateRange): SegSpan {\n    return {\n      start: this.dateToCoord(range.start),\n      end: this.dateToCoord(range.end),\n    }\n  }\n\n  durationToCoord(duration: Duration): number {\n    let { dateProfile, tDateProfile, dateEnv, isRtl } = this\n    let coord = 0\n\n    if (dateProfile) {\n      let date = dateEnv.add(dateProfile.activeRange.start, duration)\n\n      if (!tDateProfile.isTimeScale) {\n        date = startOfDay(date)\n      }\n\n      coord = this.dateToCoord(date)\n\n      // hack to overcome the left borders of non-first slat\n      if (!isRtl && coord) {\n        coord += 1\n      }\n    }\n\n    return coord\n  }\n\n  coordFromLeft(coord: number) {\n    if (this.isRtl) {\n      return this.outerCoordCache.originClientRect.width - coord\n    }\n    return coord\n  }\n\n  // returned value is between 0 and the number of snaps\n  computeDateSnapCoverage(date: DateMarker): number {\n    return computeDateSnapCoverage(date, this.tDateProfile, this.dateEnv)\n  }\n}\n\n// returned value is between 0 and the number of snaps\nexport function computeDateSnapCoverage(date: DateMarker, tDateProfile: TimelineDateProfile, dateEnv: DateEnv): number {\n  let snapDiff = dateEnv.countDurationsBetween(\n    tDateProfile.normalizedRange.start,\n    date,\n    tDateProfile.snapDuration,\n  )\n\n  if (snapDiff < 0) {\n    return 0\n  }\n\n  if (snapDiff >= tDateProfile.snapDiffToIndex.length) {\n    return tDateProfile.snapCnt\n  }\n\n  let snapDiffInt = Math.floor(snapDiff)\n  let snapCoverage = tDateProfile.snapDiffToIndex[snapDiffInt]\n\n  if (isInt(snapCoverage)) { // not an in-between value\n    snapCoverage += snapDiff - snapDiffInt // add the remainder\n  } else {\n    // a fractional value, meaning the date is not visible\n    // always round up in this case. works for start AND end dates in a range.\n    snapCoverage = Math.ceil(snapCoverage)\n  }\n\n  return snapCoverage\n}\n\nexport function coordToCss(\n  hcoord: number | null,\n  isRtl: boolean,\n): { left: CssDimValue, right: CssDimValue } {\n  if (hcoord === null) {\n    return { left: '', right: '' }\n  }\n  if (isRtl) {\n    return { right: hcoord, left: '' }\n  }\n  return { left: hcoord, right: '' }\n}\n\nexport function coordsToCss(\n  hcoords: SegSpan | null,\n  isRtl: boolean,\n): { left: CssDimValue, right: CssDimValue } {\n  if (!hcoords) {\n    return { left: '', right: '' }\n  }\n  if (isRtl) {\n    return { right: hcoords.start, left: -hcoords.end }\n  }\n  return { left: hcoords.start, right: -hcoords.end }\n}\n","import {\n  createElement, BaseComponent, CssDimValue, VNode, DateMarker, NowTimer,\n  greatestDurationDenominator, DateRange, NowIndicatorRoot, createRef,\n  findElements, RefObject, DateProfile,\n} from '@fullcalendar/common'\nimport { TimelineHeaderRows } from './TimelineHeaderRows'\nimport { coordToCss, TimelineCoords } from './TimelineCoords'\nimport { TimelineDateProfile } from './timeline-date-profile'\n\nexport interface TimelineHeaderProps {\n  dateProfile: DateProfile\n  tDateProfile: TimelineDateProfile\n  clientWidth: number | null\n  clientHeight: number | null\n  tableMinWidth: CssDimValue\n  tableColGroupNode: VNode\n  slatCoords: TimelineCoords\n  rowInnerHeights?: number[]\n  onMaxCushionWidth?: (number) => void\n}\n\nexport class TimelineHeader extends BaseComponent<TimelineHeaderProps> {\n  rootElRef: RefObject<HTMLDivElement> = createRef<HTMLDivElement>()\n\n  render() {\n    let { props, context } = this\n\n    // TODO: very repetitive\n    // TODO: make part of tDateProfile?\n    let timerUnit = greatestDurationDenominator(props.tDateProfile.slotDuration).unit\n\n    // WORKAROUND: make ignore slatCoords when out of sync with dateProfile\n    let slatCoords = props.slatCoords && props.slatCoords.dateProfile === props.dateProfile ? props.slatCoords : null\n\n    return (\n      <NowTimer unit={timerUnit}>\n        {(nowDate: DateMarker, todayRange: DateRange) => (\n          <div className=\"fc-timeline-header\" ref={this.rootElRef}>\n            <table\n              aria-hidden\n              className=\"fc-scrollgrid-sync-table\"\n              style={{ minWidth: props.tableMinWidth, width: props.clientWidth }}\n            >\n              {props.tableColGroupNode}\n              <tbody>\n                <TimelineHeaderRows\n                  dateProfile={props.dateProfile}\n                  tDateProfile={props.tDateProfile}\n                  nowDate={nowDate}\n                  todayRange={todayRange}\n                  rowInnerHeights={props.rowInnerHeights}\n                />\n              </tbody>\n            </table>\n            {context.options.nowIndicator && (\n              // need to have a container regardless of whether the current view has a visible now indicator\n              // because apparently removal of the element resets the scroll for some reasons (issue #5351).\n              // this issue doesn't happen for the timeline body however (\n              <div className=\"fc-timeline-now-indicator-container\">\n                {(slatCoords && slatCoords.isDateInRange(nowDate)) && (\n                  <NowIndicatorRoot isAxis date={nowDate}>\n                    {(rootElRef, classNames, innerElRef, innerContent) => (\n                      <div\n                        ref={rootElRef}\n                        className={['fc-timeline-now-indicator-arrow'].concat(classNames).join(' ')}\n                        style={coordToCss(slatCoords.dateToCoord(nowDate), context.isRtl)}\n                      >\n                        {innerContent}\n                      </div>\n                    )}\n                  </NowIndicatorRoot>\n                )}\n              </div>\n            )}\n          </div>\n        )}\n      </NowTimer>\n    )\n  }\n\n  componentDidMount() {\n    this.updateSize()\n  }\n\n  componentDidUpdate() {\n    this.updateSize()\n  }\n\n  updateSize() {\n    if (this.props.onMaxCushionWidth) {\n      this.props.onMaxCushionWidth(this.computeMaxCushionWidth())\n    }\n  }\n\n  computeMaxCushionWidth() { // TODO: called way too often\n    return Math.max(\n      ...findElements(this.rootElRef.current, '.fc-timeline-header-row:last-child .fc-timeline-slot-cushion').map(\n        (el) => el.getBoundingClientRect().width,\n      ),\n    )\n  }\n}\n","import {\n  createElement, isInt, BaseComponent, DateMarker, Ref, DateRange, getDateMeta, getSlotClassNames,\n  RenderHook, getDayClassNames, SlotLaneContentArg, DateProfile,\n} from '@fullcalendar/common'\nimport { TimelineDateProfile } from './timeline-date-profile'\n\nexport interface TimelineSlatCellProps {\n  date: DateMarker\n  dateProfile: DateProfile\n  tDateProfile: TimelineDateProfile\n  nowDate: DateMarker\n  todayRange: DateRange\n  isDay: boolean\n  isEm: boolean\n  elRef?: Ref<HTMLTableCellElement>\n}\n\nexport class TimelineSlatCell extends BaseComponent<TimelineSlatCellProps> {\n  render() {\n    let { props, context } = this\n    let { dateEnv, options, theme } = context\n    let { date, tDateProfile, isEm } = props\n    let dateMeta = getDateMeta(props.date, props.todayRange, props.nowDate, props.dateProfile)\n    let classNames = ['fc-timeline-slot', 'fc-timeline-slot-lane']\n    let dataAttrs = { 'data-date': dateEnv.formatIso(date, { omitTimeZoneOffset: true, omitTime: !tDateProfile.isTimeScale }) }\n    let hookProps: SlotLaneContentArg = {\n      date: dateEnv.toDate(props.date),\n      ...dateMeta,\n      view: context.viewApi,\n    }\n\n    if (isEm) {\n      classNames.push('fc-timeline-slot-em')\n    }\n\n    if (tDateProfile.isTimeScale) {\n      classNames.push(\n        isInt(dateEnv.countDurationsBetween(\n          tDateProfile.normalizedRange.start,\n          props.date,\n          tDateProfile.labelInterval,\n        )) ?\n          'fc-timeline-slot-major' :\n          'fc-timeline-slot-minor',\n      )\n    }\n\n    classNames.push(...(\n      props.isDay\n        ? getDayClassNames(dateMeta, theme)\n        : getSlotClassNames(dateMeta, theme)\n    ))\n\n    return (\n      <RenderHook\n        hookProps={hookProps}\n        classNames={options.slotLaneClassNames}\n        content={options.slotLaneContent}\n        didMount={options.slotLaneDidMount}\n        willUnmount={options.slotLaneWillUnmount}\n        elRef={props.elRef}\n      >\n        {(rootElRef, customClassNames, innerElRef, innerContent) => (\n          <td\n            ref={rootElRef}\n            className={classNames.concat(customClassNames).join(' ')}\n            {...dataAttrs}\n          >\n            <div ref={innerElRef}>{innerContent}</div>\n          </td>\n        )}\n      </RenderHook>\n    )\n  }\n}\n","import { createElement, BaseComponent, RefMap, DateMarker, DateRange, DateProfile } from '@fullcalendar/common'\nimport { TimelineDateProfile } from './timeline-date-profile'\nimport { TimelineSlatCell } from './TimelineSlatCell'\n\nexport interface TimelineSlatsContentProps {\n  dateProfile: DateProfile\n  tDateProfile: TimelineDateProfile\n  nowDate: DateMarker\n  todayRange: DateRange\n}\n\nexport interface TimelineSlatsBodyProps extends TimelineSlatsContentProps {\n  cellElRefs: RefMap<HTMLTableCellElement>\n}\n\nexport class TimelineSlatsBody extends BaseComponent<TimelineSlatsBodyProps> {\n  render() {\n    let { props } = this\n    let { tDateProfile, cellElRefs } = props\n    let { slotDates, isWeekStarts } = tDateProfile\n    let isDay = !tDateProfile.isTimeScale && !tDateProfile.largeUnit\n\n    return (\n      <tbody>\n        <tr>\n          {slotDates.map((slotDate, i) => {\n            let key = slotDate.toISOString()\n\n            return (\n              <TimelineSlatCell\n                key={key}\n                elRef={cellElRefs.createRef(key)}\n                date={slotDate}\n                dateProfile={props.dateProfile}\n                tDateProfile={tDateProfile}\n                nowDate={props.nowDate}\n                todayRange={props.todayRange}\n                isEm={isWeekStarts[i]}\n                isDay={isDay}\n              />\n            )\n          })}\n        </tr>\n      </tbody>\n    )\n  }\n}\n","import {\n  createElement, BaseComponent, multiplyDuration, RefMap, CssDimValue, VNode,\n  createRef, ScrollResponder, ScrollRequest, DateMarker,\n} from '@fullcalendar/common'\nimport { TimelineCoords } from './TimelineCoords'\nimport { TimelineSlatsBody, TimelineSlatsContentProps } from './TimelineSlatsBody'\n\nexport interface TimelineSlatsProps extends TimelineSlatsContentProps {\n  clientWidth: number | null\n  tableMinWidth: CssDimValue\n  tableColGroupNode: VNode\n  onCoords?: (coord: TimelineCoords | null) => void\n  onScrollLeftRequest?: (scrollLeft: number) => void\n}\n\nexport class TimelineSlats extends BaseComponent<TimelineSlatsProps> {\n  private rootElRef = createRef<HTMLDivElement>()\n  private cellElRefs = new RefMap<HTMLTableCellElement>()\n  private coords: TimelineCoords // for positionToHit\n  private scrollResponder: ScrollResponder\n\n  render() {\n    let { props, context } = this\n\n    return (\n      <div className=\"fc-timeline-slots\" ref={this.rootElRef}>\n        <table\n          aria-hidden\n          className={context.theme.getClass('table')}\n          style={{\n            minWidth: props.tableMinWidth,\n            width: props.clientWidth,\n          }}\n        >\n          {props.tableColGroupNode}\n          <TimelineSlatsBody\n            cellElRefs={this.cellElRefs}\n            dateProfile={props.dateProfile}\n            tDateProfile={props.tDateProfile}\n            nowDate={props.nowDate}\n            todayRange={props.todayRange}\n          />\n        </table>\n      </div>\n    )\n  }\n\n  componentDidMount() {\n    this.updateSizing()\n    this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest)\n  }\n\n  componentDidUpdate(prevProps: TimelineSlatsProps) {\n    this.updateSizing()\n\n    this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile)\n  }\n\n  componentWillUnmount() {\n    this.scrollResponder.detach()\n\n    if (this.props.onCoords) {\n      this.props.onCoords(null)\n    }\n  }\n\n  updateSizing() {\n    let { props, context } = this\n\n    if (\n      props.clientWidth !== null && // is sizing stable?\n      this.scrollResponder\n      // ^it's possible to have clientWidth immediately after mount (when returning from print view), but w/o scrollResponder\n    ) {\n      let rootEl = this.rootElRef.current\n\n      if (rootEl.offsetWidth) { // not hidden by css\n        this.coords = new TimelineCoords(\n          this.rootElRef.current,\n          collectCellEls(this.cellElRefs.currentMap, props.tDateProfile.slotDates),\n          props.dateProfile,\n          props.tDateProfile,\n          context.dateEnv,\n          context.isRtl,\n        )\n\n        if (props.onCoords) {\n          props.onCoords(this.coords)\n        }\n\n        this.scrollResponder.update(false) // TODO: wouldn't have to do this if coords were in state\n      }\n    }\n  }\n\n  handleScrollRequest = (request: ScrollRequest) => {\n    let { onScrollLeftRequest } = this.props\n    let { coords } = this\n\n    if (onScrollLeftRequest && coords) {\n      if (request.time) {\n        let scrollLeft = coords.coordFromLeft(coords.durationToCoord(request.time))\n        onScrollLeftRequest(scrollLeft)\n      }\n      return true\n    }\n\n    return null // best?\n  }\n\n  positionToHit(leftPosition) { // TODO: kill somehow\n    let { outerCoordCache } = this.coords\n    let { dateEnv, isRtl } = this.context\n    let { tDateProfile } = this.props\n    let slatIndex = outerCoordCache.leftToIndex(leftPosition)\n\n    if (slatIndex != null) {\n      // somewhat similar to what TimeGrid does. consolidate?\n      let slatWidth = outerCoordCache.getWidth(slatIndex)\n      let partial = isRtl ?\n        (outerCoordCache.rights[slatIndex] - leftPosition) / slatWidth :\n        (leftPosition - outerCoordCache.lefts[slatIndex]) / slatWidth\n      let localSnapIndex = Math.floor(partial * tDateProfile.snapsPerSlot)\n      let start = dateEnv.add(\n        tDateProfile.slotDates[slatIndex],\n        multiplyDuration(tDateProfile.snapDuration, localSnapIndex),\n      )\n      let end = dateEnv.add(start, tDateProfile.snapDuration)\n\n      return {\n        dateSpan: {\n          range: { start, end },\n          allDay: !this.props.tDateProfile.isTimeScale,\n        },\n        dayEl: this.cellElRefs.currentMap[slatIndex],\n        left: outerCoordCache.lefts[slatIndex], // TODO: make aware of snaps?\n        right: outerCoordCache.rights[slatIndex],\n      }\n    }\n\n    return null\n  }\n}\n\nfunction collectCellEls(elMap: { [key: string]: HTMLElement }, slotDates: DateMarker[]) {\n  return slotDates.map((slotDate) => {\n    let key = slotDate.toISOString()\n    return elMap[key]\n  })\n}\n","import {\n  SegSpan, SegHierarchy, groupIntersectingEntries, SegEntry, buildIsoString,\n  computeEarliestSegStart,\n} from '@fullcalendar/common'\nimport { TimelineCoords } from './TimelineCoords'\nimport { TimelineLaneSeg } from './TimelineLaneSlicer'\n\nexport interface TimelineSegPlacement {\n  seg: TimelineLaneSeg | TimelineLaneSeg[] // HACK: if array, then it's a more-link group\n  hcoords: SegSpan | null\n  top: number | null\n}\n\nexport function computeSegHCoords(\n  segs: TimelineLaneSeg[],\n  minWidth: number,\n  timelineCoords: TimelineCoords | null,\n): SegSpan[] {\n  let hcoords: SegSpan[] = []\n\n  if (timelineCoords) {\n    for (let seg of segs) {\n      let res = timelineCoords.rangeToCoords(seg)\n      let start = Math.round(res.start) // for barely-overlapping collisions\n      let end = Math.round(res.end) //\n\n      if (end - start < minWidth) {\n        end = start + minWidth\n      }\n\n      hcoords.push({ start, end })\n    }\n  }\n\n  return hcoords\n}\n\nexport function computeFgSegPlacements(\n  segs: TimelineLaneSeg[],\n  segHCoords: SegSpan[], // might not have for every seg\n  eventInstanceHeights: { [instanceId: string]: number }, // might not have for every seg\n  moreLinkHeights: { [isoStr: string]: number }, // might not have for every more-link\n  strictOrder?: boolean,\n  maxStackCnt?: number,\n): [TimelineSegPlacement[], number] { // [placements, totalHeight]\n  let segInputs: SegEntry[] = []\n  let crudePlacements: TimelineSegPlacement[] = [] // when we don't know dims\n\n  for (let i = 0; i < segs.length; i += 1) {\n    let seg = segs[i]\n    let instanceId = seg.eventRange.instance.instanceId\n    let height = eventInstanceHeights[instanceId]\n    let hcoords = segHCoords[i]\n\n    if (height && hcoords) {\n      segInputs.push({\n        index: i,\n        span: hcoords,\n        thickness: height,\n      })\n    } else {\n      crudePlacements.push({\n        seg,\n        hcoords, // might as well set hcoords if we have them. might be null\n        top: null,\n      })\n    }\n  }\n\n  let hierarchy = new SegHierarchy()\n  if (strictOrder != null) {\n    hierarchy.strictOrder = strictOrder\n  }\n  if (maxStackCnt != null) {\n    hierarchy.maxStackCnt = maxStackCnt\n  }\n\n  let hiddenEntries = hierarchy.addSegs(segInputs)\n  let hiddenPlacements = hiddenEntries.map((entry) => ({\n    seg: segs[entry.index],\n    hcoords: entry.span,\n    top: null,\n  } as TimelineSegPlacement))\n\n  let hiddenGroups = groupIntersectingEntries(hiddenEntries)\n  let moreLinkInputs: SegEntry[] = []\n  let moreLinkCrudePlacements: TimelineSegPlacement[] = []\n  const extractSeg = (entry: SegEntry) => segs[entry.index]\n\n  for (let i = 0; i < hiddenGroups.length; i += 1) {\n    let hiddenGroup = hiddenGroups[i]\n    let sortedSegs = hiddenGroup.entries.map(extractSeg)\n    let height = moreLinkHeights[buildIsoString(computeEarliestSegStart(sortedSegs))] // not optimal :(\n\n    if (height != null) {\n      // NOTE: the hiddenGroup's spanStart/spanEnd are already computed by rangeToCoords. computed during input.\n      moreLinkInputs.push({\n        index: segs.length + i, // out-of-bounds indexes map to hiddenGroups\n        thickness: height,\n        span: hiddenGroup.span,\n      })\n    } else {\n      moreLinkCrudePlacements.push({\n        seg: sortedSegs, // a Seg array signals a more-link\n        hcoords: hiddenGroup.span,\n        top: null,\n      })\n    }\n  }\n\n  // add more-links into the hierarchy, but don't limit\n  hierarchy.maxStackCnt = -1\n  hierarchy.addSegs(moreLinkInputs)\n\n  let visibleRects = hierarchy.toRects()\n  let visiblePlacements: TimelineSegPlacement[] = []\n  let maxHeight = 0\n\n  for (let rect of visibleRects) {\n    let segIndex = rect.index\n    visiblePlacements.push({\n      seg: segIndex < segs.length\n        ? segs[segIndex] // a real seg\n        : hiddenGroups[segIndex - segs.length].entries.map(extractSeg), // signals a more-link\n      hcoords: rect.span,\n      top: rect.levelCoord,\n    })\n    maxHeight = Math.max(maxHeight, rect.levelCoord + rect.thickness)\n  }\n\n  return [\n    visiblePlacements.concat(crudePlacements, hiddenPlacements, moreLinkCrudePlacements),\n    maxHeight,\n  ]\n}\n","import {\n  BaseComponent, createElement, Fragment, BgEvent, renderFill,\n  getSegMeta, DateRange, DateMarker, buildEventRangeKey,\n} from '@fullcalendar/common'\nimport { computeSegHCoords } from './event-placement'\nimport { coordsToCss, TimelineCoords } from './TimelineCoords'\nimport { TimelineLaneSeg } from './TimelineLaneSlicer'\n\nexport interface TimelineLaneBgProps {\n  businessHourSegs: TimelineLaneSeg[] | null // can be null :(\n  bgEventSegs: TimelineLaneSeg[] | null // can be null :(\n  dateSelectionSegs: TimelineLaneSeg[]\n  eventResizeSegs: TimelineLaneSeg[]\n  timelineCoords: TimelineCoords | null\n  todayRange: DateRange\n  nowDate: DateMarker\n}\n\nexport class TimelineLaneBg extends BaseComponent<TimelineLaneBgProps> {\n  render() {\n    let { props } = this\n    let highlightSeg = [].concat(props.eventResizeSegs, props.dateSelectionSegs)\n\n    return props.timelineCoords && (\n      <div className=\"fc-timeline-bg\">\n        {/* Fragments contain the keys */}\n        {this.renderSegs(props.businessHourSegs || [], props.timelineCoords, 'non-business')}\n        {this.renderSegs(props.bgEventSegs || [], props.timelineCoords, 'bg-event')}\n        {this.renderSegs(highlightSeg, props.timelineCoords, 'highlight')}\n      </div>\n    )\n  }\n\n  renderSegs(segs: TimelineLaneSeg[], timelineCoords: TimelineCoords | null, fillType: string) {\n    let { todayRange, nowDate } = this.props\n    let { isRtl } = this.context\n    let segHCoords = computeSegHCoords(segs, 0, timelineCoords)\n\n    let children = segs.map((seg, i) => {\n      let hcoords = segHCoords[i]\n      let hStyle = coordsToCss(hcoords, isRtl)\n\n      return (\n        <div\n          key={buildEventRangeKey(seg.eventRange)}\n          className=\"fc-timeline-bg-harness\"\n          style={hStyle}\n        >\n          {fillType === 'bg-event' ?\n            <BgEvent seg={seg} {...getSegMeta(seg, todayRange, nowDate)} /> :\n            renderFill(fillType)}\n        </div>\n      )\n    })\n\n    return <Fragment>{children}</Fragment>\n  }\n}\n","import {\n  DateRange, intersectRanges, addMs, DateProfile, Slicer,\n  DateProfileGenerator, DateEnv, DateMarker, Seg,\n} from '@fullcalendar/common'\nimport { normalizeRange, isValidDate, TimelineDateProfile } from './timeline-date-profile'\nimport { computeDateSnapCoverage } from './TimelineCoords'\n\nexport interface TimelineLaneSeg extends Seg {\n  // the point of this range is because it might be different than seg.eventRange.range\n  // because the date might have been rounded to the start of a week or a month\n  start: DateMarker\n  end: DateMarker\n}\n\nexport class TimelineLaneSlicer extends Slicer<\n  TimelineLaneSeg,\n  [DateProfile, DateProfileGenerator, TimelineDateProfile, DateEnv]\n> {\n  sliceRange(\n    origRange: DateRange,\n    dateProfile: DateProfile,\n    dateProfileGenerator: DateProfileGenerator,\n    tDateProfile: TimelineDateProfile,\n    dateEnv: DateEnv,\n  ): TimelineLaneSeg[] {\n    let normalRange = normalizeRange(origRange, tDateProfile, dateEnv)\n    let segs: TimelineLaneSeg[] = []\n\n    // protect against when the span is entirely in an invalid date region\n    if (\n      computeDateSnapCoverage(normalRange.start, tDateProfile, dateEnv)\n      < computeDateSnapCoverage(normalRange.end, tDateProfile, dateEnv)\n    ) {\n      // intersect the footprint's range with the grid's range\n      let slicedRange = intersectRanges(normalRange, tDateProfile.normalizedRange)\n\n      if (slicedRange) {\n        segs.push({\n          start: slicedRange.start,\n          end: slicedRange.end,\n          isStart: slicedRange.start.valueOf() === normalRange.start.valueOf()\n            && isValidDate(slicedRange.start, tDateProfile, dateProfile, dateProfileGenerator),\n          isEnd: slicedRange.end.valueOf() === normalRange.end.valueOf()\n            && isValidDate(addMs(slicedRange.end, -1), tDateProfile, dateProfile, dateProfileGenerator),\n        })\n      }\n    }\n\n    return segs\n  }\n}\n","import { StandardEvent, MinimalEventProps, createElement, BaseComponent, createFormatter } from '@fullcalendar/common'\n\nexport interface TimelineEventProps extends MinimalEventProps {\n  isTimeScale: boolean\n}\n\nconst DEFAULT_TIME_FORMAT = createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  omitZeroMinute: true,\n  meridiem: 'narrow',\n})\n\nexport class TimelineEvent extends BaseComponent<TimelineEventProps> {\n  render() {\n    let { props } = this\n\n    return (\n      <StandardEvent\n        {...props}\n        extraClassNames={['fc-timeline-event', 'fc-h-event']}\n        defaultTimeFormat={DEFAULT_TIME_FORMAT}\n        defaultDisplayEventTime={!props.isTimeScale}\n      />\n    )\n  }\n}\n","import {\n  createElement, BaseComponent, Ref, createRef, MoreLinkRoot,\n  setRef, DateProfile, DateRange, DateMarker, Fragment, getSegMeta,\n} from '@fullcalendar/common'\nimport { TimelineSegPlacement } from './event-placement'\nimport { coordsToCss } from './TimelineCoords'\nimport { TimelineEvent } from './TimelineEvent'\nimport { TimelineLaneSeg } from './TimelineLaneSlicer'\n\nexport interface TimelineLaneMoreLinkProps {\n  elRef: Ref<HTMLElement>\n  hiddenSegs: TimelineLaneSeg[]\n  placement: TimelineSegPlacement\n  dateProfile: DateProfile\n  nowDate: DateMarker\n  todayRange: DateRange\n  isTimeScale: boolean\n  eventSelection: string\n  resourceId?: string\n  isForcedInvisible: { [instanceId: string]: any }\n}\n\nexport class TimelineLaneMoreLink extends BaseComponent<TimelineLaneMoreLinkProps> {\n  rootElRef = createRef<HTMLElement>()\n\n  render() {\n    let { props, context } = this\n    let { hiddenSegs, elRef, placement, resourceId } = props\n    let { top, hcoords } = placement\n    let isVisible = hcoords && top !== null\n    let hStyle = coordsToCss(hcoords, context.isRtl)\n    let extraDateSpan = resourceId ? { resourceId } : {}\n\n    return (\n      <MoreLinkRoot\n        allDayDate={null}\n        moreCnt={hiddenSegs.length}\n        allSegs={hiddenSegs}\n        hiddenSegs={hiddenSegs}\n        alignmentElRef={this.rootElRef}\n        dateProfile={props.dateProfile}\n        todayRange={props.todayRange}\n        extraDateSpan={extraDateSpan}\n        popoverContent={() => (\n          <Fragment>\n            {hiddenSegs.map((seg) => {\n              let instanceId = seg.eventRange.instance.instanceId\n              return (\n                <div\n                  key={instanceId}\n                  style={{ visibility: props.isForcedInvisible[instanceId] ? 'hidden' : ('' as any) }}\n                >\n                  <TimelineEvent\n                    isTimeScale={props.isTimeScale}\n                    seg={seg}\n                    isDragging={false}\n                    isResizing={false}\n                    isDateSelecting={false}\n                    isSelected={instanceId === props.eventSelection}\n                    {...getSegMeta(seg, props.todayRange, props.nowDate)}\n                  />\n                </div>\n              )\n            })}\n          </Fragment>\n        )}\n      >\n        {(rootElRef, classNames, innerElRef, innerContent, handleClick, title, isExpanded, popoverId) => (\n          <a\n            ref={(el: HTMLElement | null) => {\n              setRef(rootElRef, el) // for MoreLinkRoot\n              setRef(elRef, el) // for props props\n              setRef(this.rootElRef, el) // for this component\n            }}\n            className={['fc-timeline-more-link'].concat(classNames).join(' ')}\n            style={{\n              visibility: isVisible ? ('' as any) : 'hidden',\n              top: top || 0,\n              ...hStyle,\n            }}\n            onClick={handleClick}\n            title={title}\n            aria-expanded={isExpanded}\n            aria-controls={popoverId}\n          >\n            <div ref={innerElRef} className=\"fc-timeline-more-link-inner fc-sticky\">\n              {innerContent}\n            </div>\n          </a>\n        )}\n      </MoreLinkRoot>\n    )\n  }\n}\n","import {\n  Duration, EventStore, EventUiHash, DateSpan, EventInteractionState,\n  BaseComponent, createElement, memoize, Fragment, RefMap, mapHash, createRef,\n  getSegMeta, DateMarker, DateRange, DateProfile, sortEventSegs, isPropsEqual, buildIsoString,\n  computeEarliestSegStart,\n} from '@fullcalendar/common'\nimport { TimelineDateProfile } from './timeline-date-profile'\nimport { coordsToCss, TimelineCoords } from './TimelineCoords'\nimport { TimelineLaneBg } from './TimelineLaneBg'\nimport { TimelineLaneSlicer, TimelineLaneSeg } from './TimelineLaneSlicer'\nimport { TimelineEvent } from './TimelineEvent'\nimport { TimelineLaneMoreLink } from './TimelineLaneMoreLink'\nimport { computeFgSegPlacements, computeSegHCoords, TimelineSegPlacement } from './event-placement'\n\nexport interface TimelineLaneProps extends TimelineLaneCoreProps {\n  onHeightChange?: (innerEl: HTMLElement, isStable: boolean) => void\n}\n\nexport interface TimelineLaneCoreProps {\n  nowDate: DateMarker\n  todayRange: DateRange\n  dateProfile: DateProfile\n  tDateProfile: TimelineDateProfile\n  nextDayThreshold: Duration\n  businessHours: EventStore | null\n  eventStore: EventStore | null\n  eventUiBases: EventUiHash\n  dateSelection: DateSpan | null\n  eventSelection: string\n  eventDrag: EventInteractionState | null\n  eventResize: EventInteractionState | null\n  timelineCoords: TimelineCoords | null // TODO: renamt to SLAT coords?\n  resourceId?: string // hack\n}\n\ninterface TimelineLaneState {\n  eventInstanceHeights: { [instanceId: string]: number } // integers\n  moreLinkHeights: { [isoStr: string]: number } // integers\n}\n\nexport class TimelineLane extends BaseComponent<TimelineLaneProps, TimelineLaneState> {\n  private slicer = new TimelineLaneSlicer()\n  private sortEventSegs = memoize(sortEventSegs)\n  private harnessElRefs = new RefMap<HTMLDivElement>()\n  private moreElRefs = new RefMap<HTMLDivElement>()\n  private innerElRef = createRef<HTMLDivElement>()\n  // TODO: memoize event positioning\n\n  state: TimelineLaneState = {\n    eventInstanceHeights: {},\n    moreLinkHeights: {},\n  }\n\n  render() {\n    let { props, state, context } = this\n    let { options } = context\n    let { dateProfile, tDateProfile } = props\n\n    let slicedProps = this.slicer.sliceProps(\n      props,\n      dateProfile,\n      tDateProfile.isTimeScale ? null : props.nextDayThreshold,\n      context, // wish we didn't have to pass in the rest of the args...\n      dateProfile,\n      context.dateProfileGenerator,\n      tDateProfile,\n      context.dateEnv,\n    )\n\n    let mirrorSegs =\n      (slicedProps.eventDrag ? slicedProps.eventDrag.segs as TimelineLaneSeg[] : null) ||\n      (slicedProps.eventResize ? slicedProps.eventResize.segs as TimelineLaneSeg[] : null) ||\n      []\n\n    let fgSegs = this.sortEventSegs(slicedProps.fgEventSegs, options.eventOrder) as TimelineLaneSeg[]\n    let fgSegHCoords = computeSegHCoords(fgSegs, options.eventMinWidth, props.timelineCoords)\n    let [fgPlacements, fgHeight] = computeFgSegPlacements(\n      fgSegs,\n      fgSegHCoords,\n      state.eventInstanceHeights,\n      state.moreLinkHeights,\n      options.eventOrderStrict,\n      options.eventMaxStack,\n    )\n\n    let isForcedInvisible = // TODO: more convenient\n      (slicedProps.eventDrag ? slicedProps.eventDrag.affectedInstances : null) ||\n      (slicedProps.eventResize ? slicedProps.eventResize.affectedInstances : null) ||\n      {}\n\n    return (\n      <Fragment>\n        <TimelineLaneBg\n          businessHourSegs={slicedProps.businessHourSegs}\n          bgEventSegs={slicedProps.bgEventSegs}\n          timelineCoords={props.timelineCoords}\n          eventResizeSegs={slicedProps.eventResize ? slicedProps.eventResize.segs as TimelineLaneSeg[] : [] /* bad new empty array? */}\n          dateSelectionSegs={slicedProps.dateSelectionSegs}\n          nowDate={props.nowDate}\n          todayRange={props.todayRange}\n        />\n        <div\n          className=\"fc-timeline-events fc-scrollgrid-sync-inner\"\n          ref={this.innerElRef}\n          style={{ height: fgHeight }}\n        >\n          {this.renderFgSegs(\n            fgPlacements,\n            isForcedInvisible,\n            false,\n            false,\n            false,\n          )}\n          {this.renderFgSegs(\n            buildMirrorPlacements(mirrorSegs, props.timelineCoords, fgPlacements),\n            {},\n            Boolean(slicedProps.eventDrag),\n            Boolean(slicedProps.eventResize),\n            false, // because mirror is never drawn for date selection\n          )}\n        </div>\n      </Fragment>\n    )\n  }\n\n  componentDidMount() {\n    this.updateSize()\n  }\n\n  componentDidUpdate(prevProps: TimelineLaneProps, prevState: TimelineLaneState) {\n    if (\n      prevProps.eventStore !== this.props.eventStore || // external thing changed?\n      prevProps.timelineCoords !== this.props.timelineCoords || // external thing changed?\n      prevState.moreLinkHeights !== this.state.moreLinkHeights // HACK. see addStateEquality\n    ) {\n      this.updateSize()\n    }\n  }\n\n  updateSize() {\n    let { props } = this\n    let { timelineCoords } = props\n\n    if (props.onHeightChange) {\n      props.onHeightChange(this.innerElRef.current, false)\n    }\n\n    if (timelineCoords) {\n      this.setState({\n        eventInstanceHeights: mapHash(this.harnessElRefs.currentMap, (harnessEl) => (\n          Math.round(harnessEl.getBoundingClientRect().height)\n        )),\n        moreLinkHeights: mapHash(this.moreElRefs.currentMap, (moreEl) => (\n          Math.round(moreEl.getBoundingClientRect().height)\n        )),\n      }, () => {\n        if (props.onHeightChange) {\n          props.onHeightChange(this.innerElRef.current, true)\n        }\n      })\n    }\n  }\n\n  renderFgSegs(\n    segPlacements: TimelineSegPlacement[],\n    isForcedInvisible: { [instanceId: string]: any },\n    isDragging: boolean,\n    isResizing: boolean,\n    isDateSelecting: boolean,\n  ) {\n    let { harnessElRefs, moreElRefs, props, context } = this\n    let isMirror = isDragging || isResizing || isDateSelecting\n\n    return (\n      <Fragment>\n        {segPlacements.map((segPlacement) => {\n          let { seg, hcoords, top } = segPlacement\n\n          if (Array.isArray(seg)) { // a more-link\n            let isoStr = buildIsoString(computeEarliestSegStart(seg))\n            return (\n              <TimelineLaneMoreLink\n                key={'m:' + isoStr /* \"m\" for \"more\" */}\n                elRef={moreElRefs.createRef(isoStr)}\n                hiddenSegs={seg}\n                placement={segPlacement}\n                dateProfile={props.dateProfile}\n                nowDate={props.nowDate}\n                todayRange={props.todayRange}\n                isTimeScale={props.tDateProfile.isTimeScale}\n                eventSelection={props.eventSelection}\n                resourceId={props.resourceId}\n                isForcedInvisible={isForcedInvisible}\n              />\n            )\n          }\n\n          let instanceId = seg.eventRange.instance.instanceId\n          let isVisible = isMirror || Boolean(!isForcedInvisible[instanceId] && hcoords && top !== null)\n          let hStyle = coordsToCss(hcoords, context.isRtl)\n\n          return (\n            <div\n              key={'e:' + instanceId /* \"e\" for \"event\" */}\n              ref={isMirror ? null : harnessElRefs.createRef(instanceId)}\n              className=\"fc-timeline-event-harness\"\n              style={{\n                visibility: isVisible ? ('' as any) : 'hidden',\n                top: top || 0,\n                ...hStyle,\n              }}\n            >\n              <TimelineEvent\n                isTimeScale={props.tDateProfile.isTimeScale}\n                seg={seg}\n                isDragging={isDragging}\n                isResizing={isResizing}\n                isDateSelecting={isDateSelecting}\n                isSelected={instanceId === props.eventSelection /* TODO: bad for mirror? */}\n                {...getSegMeta(seg, props.todayRange, props.nowDate)}\n              />\n            </div>\n          )\n        })}\n      </Fragment>\n    )\n  }\n}\n\nTimelineLane.addStateEquality({\n  eventInstanceHeights: isPropsEqual,\n  moreLinkHeights: isPropsEqual,\n})\n\nfunction buildMirrorPlacements(\n  mirrorSegs: TimelineLaneSeg[],\n  timelineCoords: TimelineCoords | null,\n  fgPlacements: TimelineSegPlacement[],\n): TimelineSegPlacement[] {\n  if (!mirrorSegs.length || !timelineCoords) {\n    return []\n  }\n  let topsByInstanceId = buildAbsoluteTopHash(fgPlacements) // TODO: cache this at first render?\n  return mirrorSegs.map((seg) => ({\n    seg,\n    hcoords: timelineCoords.rangeToCoords(seg),\n    top: topsByInstanceId[seg.eventRange.instance.instanceId],\n  }))\n}\n\nfunction buildAbsoluteTopHash(placements: TimelineSegPlacement[]) {\n  let topsByInstanceId: { [instanceId: string]: number } = {}\n\n  for (let placement of placements) {\n    let { seg } = placement\n    if (!Array.isArray(seg)) { // doesn't represent a more-link\n      topsByInstanceId[seg.eventRange.instance.instanceId] = placement.top\n    }\n  }\n\n  return topsByInstanceId\n}\n","import {\n  createElement, createRef, ViewProps, Hit, DateComponent, CssDimValue, VNode, DateMarker, NowTimer,\n  greatestDurationDenominator, DateRange, NowIndicatorRoot, Fragment,\n} from '@fullcalendar/common'\nimport { coordToCss, TimelineCoords } from './TimelineCoords'\nimport { TimelineSlats } from './TimelineSlats'\nimport { TimelineLane } from './TimelineLane'\nimport { TimelineDateProfile } from './timeline-date-profile'\n\nexport interface TimelinGridProps extends ViewProps {\n  tDateProfile: TimelineDateProfile\n  clientWidth: number | null\n  clientHeight: number | null\n  tableMinWidth: CssDimValue\n  tableColGroupNode: VNode\n  onSlatCoords?: (coords: TimelineCoords) => void\n  onScrollLeftRequest?: (scrollLeft: number) => void\n}\n\ninterface TimelineGridState {\n  coords: TimelineCoords | null\n}\n\nexport class TimelineGrid extends DateComponent<TimelinGridProps, TimelineGridState> {\n  private slatsRef = createRef<TimelineSlats>()\n\n  state: TimelineGridState = {\n    coords: null,\n  }\n\n  render() {\n    let { props, state, context } = this\n    let { options } = context\n    let { dateProfile, tDateProfile } = props\n    let timerUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit\n\n    return (\n      <div\n        className=\"fc-timeline-body\"\n        ref={this.handeEl}\n        style={{\n          minWidth: props.tableMinWidth,\n          height: props.clientHeight,\n          width: props.clientWidth,\n        }}\n      >\n        <NowTimer unit={timerUnit}>\n          {(nowDate: DateMarker, todayRange: DateRange) => (\n            <Fragment>\n              <TimelineSlats\n                ref={this.slatsRef}\n                dateProfile={dateProfile}\n                tDateProfile={tDateProfile}\n                nowDate={nowDate}\n                todayRange={todayRange}\n                clientWidth={props.clientWidth}\n                tableColGroupNode={props.tableColGroupNode}\n                tableMinWidth={props.tableMinWidth}\n                onCoords={this.handleCoords}\n                onScrollLeftRequest={props.onScrollLeftRequest}\n              />\n              <TimelineLane\n                dateProfile={dateProfile}\n                tDateProfile={props.tDateProfile}\n                nowDate={nowDate}\n                todayRange={todayRange}\n                nextDayThreshold={options.nextDayThreshold}\n                businessHours={props.businessHours}\n                eventStore={props.eventStore}\n                eventUiBases={props.eventUiBases}\n                dateSelection={props.dateSelection}\n                eventSelection={props.eventSelection}\n                eventDrag={props.eventDrag}\n                eventResize={props.eventResize}\n                timelineCoords={state.coords}\n              />\n              {(options.nowIndicator && state.coords && state.coords.isDateInRange(nowDate)) && (\n                <div className=\"fc-timeline-now-indicator-container\">\n                  <NowIndicatorRoot isAxis={false} date={nowDate}>\n                    {(rootElRef, classNames, innerElRef, innerContent) => (\n                      <div\n                        ref={rootElRef}\n                        className={['fc-timeline-now-indicator-line'].concat(classNames).join(' ')}\n                        style={coordToCss(state.coords.dateToCoord(nowDate), context.isRtl)}\n                      >\n                        {innerContent}\n                      </div>\n                    )}\n                  </NowIndicatorRoot>\n                </div>\n              )}\n            </Fragment>\n          )}\n        </NowTimer>\n      </div>\n    )\n  }\n\n  handeEl = (el: HTMLElement | null) => {\n    if (el) {\n      this.context.registerInteractiveComponent(this, { el })\n    } else {\n      this.context.unregisterInteractiveComponent(this)\n    }\n  }\n\n  handleCoords = (coords: TimelineCoords) => {\n    this.setState({ coords })\n\n    if (this.props.onSlatCoords) {\n      this.props.onSlatCoords(coords)\n    }\n  }\n\n  // Hit System\n  // ------------------------------------------------------------------------------------------\n\n  queryHit(positionLeft: number, positionTop: number, elWidth: number, elHeight: number): Hit {\n    let slats = this.slatsRef.current\n    let slatHit = slats.positionToHit(positionLeft)\n\n    if (slatHit) {\n      return {\n        dateProfile: this.props.dateProfile,\n        dateSpan: slatHit.dateSpan,\n        rect: {\n          left: slatHit.left,\n          right: slatHit.right,\n          top: 0,\n          bottom: elHeight,\n        },\n        dayEl: slatHit.dayEl,\n        layer: 0,\n      }\n    }\n\n    return null\n  }\n}\n","import {\n  createElement, ViewProps, memoize, ChunkContentCallbackArgs, createRef, ViewRoot,\n  DateComponent, ScrollGridSectionConfig, renderScrollShim, getStickyHeaderDates, getStickyFooterScrollbar,\n} from '@fullcalendar/common'\nimport { ScrollGrid } from '@fullcalendar/scrollgrid'\nimport { buildTimelineDateProfile, TimelineDateProfile } from './timeline-date-profile'\nimport { TimelineHeader } from './TimelineHeader'\nimport { TimelineGrid } from './TimelineGrid'\nimport { TimelineCoords } from './TimelineCoords'\n\ninterface TimelineViewState {\n  slatCoords: TimelineCoords | null\n  slotCushionMaxWidth: number | null\n}\n\nexport class TimelineView extends DateComponent<ViewProps, TimelineViewState> { // would make this abstract, but TS complains\n  private buildTimelineDateProfile = memoize(buildTimelineDateProfile)\n  private scrollGridRef = createRef<ScrollGrid>()\n\n  state = {\n    slatCoords: null,\n    slotCushionMaxWidth: null,\n  }\n\n  render() {\n    let { props, state, context } = this\n    let { options } = context\n    let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(options)\n    let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(options)\n\n    let tDateProfile = this.buildTimelineDateProfile(\n      props.dateProfile,\n      context.dateEnv,\n      options,\n      context.dateProfileGenerator,\n    )\n\n    let extraClassNames = [\n      'fc-timeline',\n      options.eventOverlap === false ? 'fc-timeline-overlap-disabled' : '',\n    ]\n\n    let { slotMinWidth } = options\n    let slatCols = buildSlatCols(tDateProfile, slotMinWidth || this.computeFallbackSlotMinWidth(tDateProfile))\n\n    let sections: ScrollGridSectionConfig[] = [\n      {\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        chunks: [{\n          key: 'timeline',\n          content: (contentArg: ChunkContentCallbackArgs) => (\n            <TimelineHeader\n              dateProfile={props.dateProfile}\n              clientWidth={contentArg.clientWidth}\n              clientHeight={contentArg.clientHeight}\n              tableMinWidth={contentArg.tableMinWidth}\n              tableColGroupNode={contentArg.tableColGroupNode}\n              tDateProfile={tDateProfile}\n              slatCoords={state.slatCoords}\n              onMaxCushionWidth={slotMinWidth ? null : this.handleMaxCushionWidth}\n            />\n          ),\n        }],\n      },\n      {\n        type: 'body',\n        key: 'body',\n        liquid: true,\n        chunks: [{\n          key: 'timeline',\n          content: (contentArg: ChunkContentCallbackArgs) => (\n            <TimelineGrid\n              {...props}\n              clientWidth={contentArg.clientWidth}\n              clientHeight={contentArg.clientHeight}\n              tableMinWidth={contentArg.tableMinWidth}\n              tableColGroupNode={contentArg.tableColGroupNode}\n              tDateProfile={tDateProfile}\n              onSlatCoords={this.handleSlatCoords}\n              onScrollLeftRequest={this.handleScrollLeftRequest}\n            />\n          ),\n        }],\n      },\n    ]\n\n    if (stickyFooterScrollbar) {\n      sections.push({\n        type: 'footer',\n        key: 'footer',\n        isSticky: true,\n        chunks: [{\n          key: 'timeline',\n          content: renderScrollShim,\n        }],\n      })\n    }\n\n    return (\n      <ViewRoot viewSpec={context.viewSpec}>\n        {(rootElRef, classNames) => (\n          <div ref={rootElRef} className={extraClassNames.concat(classNames).join(' ')}>\n            <ScrollGrid\n              ref={this.scrollGridRef}\n              liquid={!props.isHeightAuto && !props.forPrint}\n              collapsibleWidth={false}\n              colGroups={[\n                { cols: slatCols },\n              ]}\n              sections={sections}\n            />\n          </div>\n        )}\n      </ViewRoot>\n    )\n  }\n\n  handleSlatCoords = (slatCoords: TimelineCoords | null) => {\n    this.setState({ slatCoords })\n  }\n\n  handleScrollLeftRequest = (scrollLeft: number) => {\n    let scrollGrid = this.scrollGridRef.current\n    scrollGrid.forceScrollLeft(0, scrollLeft)\n  }\n\n  handleMaxCushionWidth = (slotCushionMaxWidth) => {\n    this.setState({\n      slotCushionMaxWidth: Math.ceil(slotCushionMaxWidth), // for less rerendering TODO: DRY\n    })\n  }\n\n  computeFallbackSlotMinWidth(tDateProfile: TimelineDateProfile) { // TODO: duplicate definition\n    return Math.max(30, ((this.state.slotCushionMaxWidth || 0) / tDateProfile.slotsPerLabel))\n  }\n}\n\nexport function buildSlatCols(tDateProfile: TimelineDateProfile, slotMinWidth?: number) {\n  return [{\n    span: tDateProfile.slotCnt,\n    minWidth: slotMinWidth || 1, // needs to be a non-zero number to trigger horizontal scrollbars!??????\n  }]\n}\n","import { createPlugin } from '@fullcalendar/common'\n\nimport premiumCommonPlugin from '@fullcalendar/premium-common' // eslint-disable-line import/no-duplicates\n// ensure ambient declarations\nimport '@fullcalendar/premium-common' // eslint-disable-line import/no-duplicates\n\nimport { TimelineView } from './TimelineView'\nimport './main.css'\n\nexport { TimelineView }\nexport { buildSlatCols } from './TimelineView'\nexport { TimelineLane, TimelineLaneProps, TimelineLaneCoreProps } from './TimelineLane'\nexport { TimelineLaneBg } from './TimelineLaneBg'\nexport { TimelineHeader } from './TimelineHeader'\nexport { TimelineSlats } from './TimelineSlats'\nexport { TimelineDateProfile, buildTimelineDateProfile } from './timeline-date-profile'\nexport { TimelineCoords, coordToCss, coordsToCss } from './TimelineCoords'\nexport { TimelineLaneSlicer, TimelineLaneSeg } from './TimelineLaneSlicer'\nexport { TimelineHeaderRows } from './TimelineHeaderRows'\n\nexport default createPlugin({\n  deps: [\n    premiumCommonPlugin,\n  ],\n  initialView: 'timelineDay',\n  views: {\n\n    timeline: {\n      component: TimelineView,\n      usesMinMaxTime: true,\n      eventResizableFromStart: true, // how is this consumed for TimelineView tho?\n    },\n\n    timelineDay: {\n      type: 'timeline',\n      duration: { days: 1 },\n    },\n\n    timelineWeek: {\n      type: 'timeline',\n      duration: { weeks: 1 },\n    },\n\n    timelineMonth: {\n      type: 'timeline',\n      duration: { months: 1 },\n    },\n\n    timelineYear: {\n      type: 'timeline',\n      duration: { years: 1 },\n    },\n\n  },\n})\n"]},"metadata":{},"sourceType":"module"}