{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.memoize = memoize;\nexports.without = without;\nexports.union = union;\n\nfunction memoize(fn) {\n  let result = null;\n\n  const memoized = () => {\n    if (result == null) {\n      result = fn();\n    }\n\n    return result;\n  };\n\n  return memoized;\n}\n\nfunction without(items, item) {\n  return items.filter(i => i !== item);\n}\n\nfunction union(itemsA, itemsB) {\n  const set = new Set();\n\n  const insertItem = item => set.add(item);\n\n  itemsA.forEach(insertItem);\n  itemsB.forEach(insertItem);\n  const result = [];\n  set.forEach(key => result.push(key));\n  return result;\n}","map":{"version":3,"mappings":";;;;;QAEgBA;QAcAC;QAIAC;;SAlBAF,QAAWG,IAAsB;EAChD,IAAIC,MAAM,GAAa,IAAvB;;EACA,MAAMC,QAAQ,SAAS;IACtB,IAAID,MAAM,IAAI,IAAd,EAAoB;MACnBA,MAAM,GAAGD,EAAE,EAAXC;IACA;;IACD,OAAOA,MAAP;EACA,CALD;;EAMA,OAAOC,QAAP;AACA;;SAKeJ,QAAWK,OAAYC,MAAS;EAC/C,OAAOD,KAAK,CAACE,MAANF,CAAcG,CAAF,IAAQA,CAAC,KAAKF,IAA1BD,CAAP;AACA;;SAEeJ,MAAiCQ,QAAaC,QAAa;EAC1E,MAAMC,GAAG,GAAG,IAAIC,GAAJ,EAAZ;;EACA,MAAMC,UAAU,GAAIP,IAAJ,IAAgBK,GAAG,CAACG,GAAJH,CAAQL,IAARK,CAAhC;;EACAF,MAAM,CAACM,OAAPN,CAAeI,UAAfJ;EACAC,MAAM,CAACK,OAAPL,CAAeG,UAAfH;EAEA,MAAMP,MAAM,GAAQ,EAApB;EACAQ,GAAG,CAACI,OAAJJ,CAAaK,GAAF,IAAUb,MAAM,CAACc,IAAPd,CAAYa,GAAZb,CAArBQ;EACA,OAAOR,MAAP;AACA","names":["memoize","without","union","fn","result","memoized","items","item","filter","i","itemsA","itemsB","set","Set","insertItem","add","forEach","key","push"],"sources":["../../../src/utils/js_utils.ts"],"sourcesContent":["// cheap lodash replacements\n\nexport function memoize<T>(fn: () => T): () => T {\n\tlet result: T | null = null\n\tconst memoized = () => {\n\t\tif (result == null) {\n\t\t\tresult = fn()\n\t\t}\n\t\treturn result\n\t}\n\treturn memoized\n}\n\n/**\n * drop-in replacement for _.without\n */\nexport function without<T>(items: T[], item: T) {\n\treturn items.filter((i) => i !== item)\n}\n\nexport function union<T extends string | number>(itemsA: T[], itemsB: T[]) {\n\tconst set = new Set<T>()\n\tconst insertItem = (item: T) => set.add(item)\n\titemsA.forEach(insertItem)\n\titemsB.forEach(insertItem)\n\n\tconst result: T[] = []\n\tset.forEach((key) => result.push(key))\n\treturn result\n}\n"]},"metadata":{},"sourceType":"script"}