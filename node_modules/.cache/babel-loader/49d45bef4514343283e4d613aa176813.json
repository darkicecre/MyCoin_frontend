{"ast":null,"code":"/*!\nFullCalendar Scheduler v5.10.2\nDocs & License: https://fullcalendar.io/scheduler\n(c) 2021 Adam Shaw\n*/\nimport { Emitter, DelayedRunner, removeElement, computeEdges, findElements, translateRect, computeInnerRect, applyStyle, createRef, setRef, getIsRtlScrollbarOnLeft, createElement, Scroller, isPropsEqual, BaseComponent, memoizeArraylike, renderMicroColGroup, RefMap, memoizeHashlike, getScrollGridClassNames, getCanVGrowWithinCell, Fragment, getSectionClassNames, getAllowYScrolling, getSectionHasLiquidHeight, renderChunkContent, config, computeShrinkWidth, getScrollbarWidths, collectFromHash, mapHash, isArraysEqual, sanitizeShrinkWidth, hasShrinkWidth, compareObjs, isColPropsEqual, createPlugin } from '@fullcalendar/common';\nimport premiumCommonPlugin from '@fullcalendar/premium-common';\nimport { __extends, __assign, __spreadArray } from 'tslib';\nvar WHEEL_EVENT_NAMES = 'wheel mousewheel DomMouseScroll MozMousePixelScroll'.split(' ');\n/*\nALSO, with the ability to disable touch\n*/\n\nvar ScrollListener =\n/** @class */\nfunction () {\n  function ScrollListener(el) {\n    var _this = this;\n\n    this.el = el;\n    this.emitter = new Emitter();\n    this.isScrolling = false;\n    this.isTouching = false; // user currently has finger down?\n\n    this.isRecentlyWheeled = false;\n    this.isRecentlyScrolled = false;\n    this.wheelWaiter = new DelayedRunner(this._handleWheelWaited.bind(this));\n    this.scrollWaiter = new DelayedRunner(this._handleScrollWaited.bind(this)); // Handlers\n    // ----------------------------------------------------------------------------------------------\n\n    this.handleScroll = function () {\n      _this.startScroll();\n\n      _this.emitter.trigger('scroll', _this.isRecentlyWheeled, _this.isTouching);\n\n      _this.isRecentlyScrolled = true;\n\n      _this.scrollWaiter.request(500);\n    }; // will fire *before* the scroll event is fired (might not cause a scroll)\n\n\n    this.handleWheel = function () {\n      _this.isRecentlyWheeled = true;\n\n      _this.wheelWaiter.request(500);\n    }; // will fire *before* the scroll event is fired (might not cause a scroll)\n\n\n    this.handleTouchStart = function () {\n      _this.isTouching = true;\n    };\n\n    this.handleTouchEnd = function () {\n      _this.isTouching = false; // if the user ended their touch, and the scroll area wasn't moving,\n      // we consider this to be the end of the scroll.\n\n      if (!_this.isRecentlyScrolled) {\n        _this.endScroll(); // won't fire if already ended\n\n      }\n    };\n\n    el.addEventListener('scroll', this.handleScroll);\n    el.addEventListener('touchstart', this.handleTouchStart, {\n      passive: true\n    });\n    el.addEventListener('touchend', this.handleTouchEnd);\n\n    for (var _i = 0, WHEEL_EVENT_NAMES_1 = WHEEL_EVENT_NAMES; _i < WHEEL_EVENT_NAMES_1.length; _i++) {\n      var eventName = WHEEL_EVENT_NAMES_1[_i];\n      el.addEventListener(eventName, this.handleWheel);\n    }\n  }\n\n  ScrollListener.prototype.destroy = function () {\n    var el = this.el;\n    el.removeEventListener('scroll', this.handleScroll);\n    el.removeEventListener('touchstart', this.handleTouchStart, {\n      passive: true\n    });\n    el.removeEventListener('touchend', this.handleTouchEnd);\n\n    for (var _i = 0, WHEEL_EVENT_NAMES_2 = WHEEL_EVENT_NAMES; _i < WHEEL_EVENT_NAMES_2.length; _i++) {\n      var eventName = WHEEL_EVENT_NAMES_2[_i];\n      el.removeEventListener(eventName, this.handleWheel);\n    }\n  }; // Start / Stop\n  // ----------------------------------------------------------------------------------------------\n\n\n  ScrollListener.prototype.startScroll = function () {\n    if (!this.isScrolling) {\n      this.isScrolling = true;\n      this.emitter.trigger('scrollStart', this.isRecentlyWheeled, this.isTouching);\n    }\n  };\n\n  ScrollListener.prototype.endScroll = function () {\n    if (this.isScrolling) {\n      this.emitter.trigger('scrollEnd');\n      this.isScrolling = false;\n      this.isRecentlyScrolled = true;\n      this.isRecentlyWheeled = false;\n      this.scrollWaiter.clear();\n      this.wheelWaiter.clear();\n    }\n  };\n\n  ScrollListener.prototype._handleScrollWaited = function () {\n    this.isRecentlyScrolled = false; // only end the scroll if not currently touching.\n    // if touching, the scrolling will end later, on touchend.\n\n    if (!this.isTouching) {\n      this.endScroll(); // won't fire if already ended\n    }\n  };\n\n  ScrollListener.prototype._handleWheelWaited = function () {\n    this.isRecentlyWheeled = false;\n  };\n\n  return ScrollListener;\n}(); // TODO: assume the el has no borders?\n\n\nfunction getScrollCanvasOrigin(scrollEl) {\n  var rect = scrollEl.getBoundingClientRect();\n  var edges = computeEdges(scrollEl); // TODO: pass in isRtl?\n\n  return {\n    left: rect.left + edges.borderLeft + edges.scrollbarLeft - getScrollFromLeftEdge(scrollEl),\n    top: rect.top + edges.borderTop - scrollEl.scrollTop\n  };\n}\n\nfunction getScrollFromLeftEdge(el) {\n  var scrollLeft = el.scrollLeft;\n  var computedStyles = window.getComputedStyle(el); // TODO: pass in isRtl instead?\n\n  if (computedStyles.direction === 'rtl') {\n    switch (getRtlScrollSystem()) {\n      case 'negative':\n        scrollLeft *= -1;\n      // convert to 'reverse'. fall through...\n\n      case 'reverse':\n        // scrollLeft is distance between scrollframe's right edge scrollcanvas's right edge\n        scrollLeft = el.scrollWidth - scrollLeft - el.clientWidth;\n    }\n  }\n\n  return scrollLeft;\n}\n\nfunction setScrollFromLeftEdge(el, scrollLeft) {\n  var computedStyles = window.getComputedStyle(el); // TODO: pass in isRtl instead?\n\n  if (computedStyles.direction === 'rtl') {\n    switch (getRtlScrollSystem()) {\n      case 'reverse':\n        scrollLeft = el.scrollWidth - scrollLeft;\n        break;\n\n      case 'negative':\n        scrollLeft = -(el.scrollWidth - scrollLeft);\n        break;\n    }\n  }\n\n  el.scrollLeft = scrollLeft;\n} // Horizontal Scroll System Detection\n// ----------------------------------------------------------------------------------------------\n\n\nvar _rtlScrollSystem;\n\nfunction getRtlScrollSystem() {\n  return _rtlScrollSystem || (_rtlScrollSystem = detectRtlScrollSystem());\n}\n\nfunction detectRtlScrollSystem() {\n  var el = document.createElement('div');\n  el.style.position = 'absolute';\n  el.style.top = '-1000px';\n  el.style.width = '1px';\n  el.style.height = '1px';\n  el.style.overflow = 'scroll';\n  el.style.direction = 'rtl';\n  el.style.fontSize = '100px';\n  el.innerHTML = 'A';\n  document.body.appendChild(el);\n  var system;\n\n  if (el.scrollLeft > 0) {\n    system = 'positive'; // scroll is a positive number from the left edge\n  } else {\n    el.scrollLeft = 1;\n\n    if (el.scrollLeft > 0) {\n      system = 'reverse'; // scroll is a positive number from the right edge\n    } else {\n      system = 'negative'; // scroll is a negative number from the right edge\n    }\n  }\n\n  removeElement(el);\n  return system;\n}\n\nvar IS_MS_EDGE = typeof navigator !== 'undefined' && /Edge/.test(navigator.userAgent); // TODO: what about Chromeum-based Edge?\n\nvar STICKY_SELECTOR = '.fc-sticky';\n/*\nuseful beyond the native position:sticky for these reasons:\n- support in IE11\n- nice centering support\n\nREQUIREMENT: fc-sticky elements, if the fc-sticky className is taken away, should NOT have relative or absolute positioning.\nThis is because we attach the coords with JS, and the VDOM might take away the fc-sticky class but doesn't know kill the positioning.\n\nTODO: don't query text-align:center. isn't compatible with flexbox centering. instead, check natural X coord within parent container\n*/\n\nvar StickyScrolling =\n/** @class */\nfunction () {\n  function StickyScrolling(scrollEl, isRtl) {\n    var _this = this;\n\n    this.scrollEl = scrollEl;\n    this.isRtl = isRtl;\n    this.usingRelative = null;\n\n    this.updateSize = function () {\n      var scrollEl = _this.scrollEl;\n      var els = findElements(scrollEl, STICKY_SELECTOR);\n\n      var elGeoms = _this.queryElGeoms(els);\n\n      var viewportWidth = scrollEl.clientWidth;\n      var viewportHeight = scrollEl.clientHeight;\n\n      if (_this.usingRelative) {\n        var elDestinations = _this.computeElDestinations(elGeoms, viewportWidth); // read before prepPositioning\n\n\n        assignRelativePositions(els, elGeoms, elDestinations, viewportWidth, viewportHeight);\n      } else {\n        assignStickyPositions(els, elGeoms, viewportWidth);\n      }\n    };\n\n    this.usingRelative = !getStickySupported() || // IE11\n    // https://stackoverflow.com/questions/56835658/in-microsoft-edge-sticky-positioning-doesnt-work-when-combined-with-dir-rtl\n    IS_MS_EDGE && isRtl;\n\n    if (this.usingRelative) {\n      this.listener = new ScrollListener(scrollEl);\n      this.listener.emitter.on('scrollEnd', this.updateSize);\n    }\n  }\n\n  StickyScrolling.prototype.destroy = function () {\n    if (this.listener) {\n      this.listener.destroy();\n    }\n  };\n\n  StickyScrolling.prototype.queryElGeoms = function (els) {\n    var _a = this,\n        scrollEl = _a.scrollEl,\n        isRtl = _a.isRtl;\n\n    var canvasOrigin = getScrollCanvasOrigin(scrollEl);\n    var elGeoms = [];\n\n    for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {\n      var el = els_1[_i];\n      var parentBound = translateRect(computeInnerRect(el.parentNode, true, true), // weird way to call this!!!\n      -canvasOrigin.left, -canvasOrigin.top);\n      var elRect = el.getBoundingClientRect();\n      var computedStyles = window.getComputedStyle(el);\n      var textAlign = window.getComputedStyle(el.parentNode).textAlign; // ask the parent\n\n      var naturalBound = null;\n\n      if (textAlign === 'start') {\n        textAlign = isRtl ? 'right' : 'left';\n      } else if (textAlign === 'end') {\n        textAlign = isRtl ? 'left' : 'right';\n      }\n\n      if (computedStyles.position !== 'sticky') {\n        naturalBound = translateRect(elRect, -canvasOrigin.left - (parseFloat(computedStyles.left) || 0), // could be 'auto'\n        -canvasOrigin.top - (parseFloat(computedStyles.top) || 0));\n      }\n\n      elGeoms.push({\n        parentBound: parentBound,\n        naturalBound: naturalBound,\n        elWidth: elRect.width,\n        elHeight: elRect.height,\n        textAlign: textAlign\n      });\n    }\n\n    return elGeoms;\n  }; // only for IE\n\n\n  StickyScrolling.prototype.computeElDestinations = function (elGeoms, viewportWidth) {\n    var scrollEl = this.scrollEl;\n    var viewportTop = scrollEl.scrollTop;\n    var viewportLeft = getScrollFromLeftEdge(scrollEl);\n    var viewportRight = viewportLeft + viewportWidth;\n    return elGeoms.map(function (elGeom) {\n      var elWidth = elGeom.elWidth,\n          elHeight = elGeom.elHeight,\n          parentBound = elGeom.parentBound,\n          naturalBound = elGeom.naturalBound;\n      var destLeft; // relative to canvas topleft\n\n      var destTop; // \"\n\n      switch (elGeom.textAlign) {\n        case 'left':\n          destLeft = viewportLeft;\n          break;\n\n        case 'right':\n          destLeft = viewportRight - elWidth;\n          break;\n\n        case 'center':\n          destLeft = (viewportLeft + viewportRight) / 2 - elWidth / 2; /// noooo, use half-width insteadddddddd\n\n          break;\n      }\n\n      destLeft = Math.min(destLeft, parentBound.right - elWidth);\n      destLeft = Math.max(destLeft, parentBound.left);\n      destTop = viewportTop;\n      destTop = Math.min(destTop, parentBound.bottom - elHeight);\n      destTop = Math.max(destTop, naturalBound.top); // better to use natural top for upper bound\n\n      return {\n        left: destLeft,\n        top: destTop\n      };\n    });\n  };\n\n  return StickyScrolling;\n}();\n\nfunction assignRelativePositions(els, elGeoms, elDestinations, viewportWidth, viewportHeight) {\n  els.forEach(function (el, i) {\n    var _a = elGeoms[i],\n        naturalBound = _a.naturalBound,\n        parentBound = _a.parentBound;\n    var parentWidth = parentBound.right - parentBound.left;\n    var parentHeight = parentBound.bottom - parentBound.bottom;\n    var left;\n    var top;\n\n    if (parentWidth > viewportWidth || parentHeight > viewportHeight) {\n      left = elDestinations[i].left - naturalBound.left;\n      top = elDestinations[i].top - naturalBound.top;\n    } else {\n      // if parent container can be completely in view, we don't need stickiness\n      left = '';\n      top = '';\n    }\n\n    applyStyle(el, {\n      position: 'relative',\n      left: left,\n      right: -left,\n      top: top\n    });\n  });\n}\n\nfunction assignStickyPositions(els, elGeoms, viewportWidth) {\n  els.forEach(function (el, i) {\n    var _a = elGeoms[i],\n        textAlign = _a.textAlign,\n        elWidth = _a.elWidth,\n        parentBound = _a.parentBound;\n    var parentWidth = parentBound.right - parentBound.left;\n    var left;\n\n    if (textAlign === 'center' && parentWidth > viewportWidth) {\n      left = (viewportWidth - elWidth) / 2;\n    } else {\n      // if parent container can be completely in view, we don't need stickiness\n      left = '';\n    }\n\n    applyStyle(el, {\n      left: left,\n      right: left,\n      top: 0\n    });\n  });\n}\n\nvar _isStickySupported;\n\nfunction getStickySupported() {\n  if (_isStickySupported == null) {\n    _isStickySupported = computeStickySupported();\n  }\n\n  return _isStickySupported;\n}\n\nfunction computeStickySupported() {\n  var el = document.createElement('div');\n  el.style.position = 'sticky';\n  document.body.appendChild(el);\n  var val = window.getComputedStyle(el).position;\n  removeElement(el);\n  return val === 'sticky';\n}\n\nvar ClippedScroller =\n/** @class */\nfunction (_super) {\n  __extends(ClippedScroller, _super);\n\n  function ClippedScroller() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.elRef = createRef();\n    _this.state = {\n      xScrollbarWidth: 0,\n      yScrollbarWidth: 0\n    };\n\n    _this.handleScroller = function (scroller) {\n      _this.scroller = scroller;\n      setRef(_this.props.scrollerRef, scroller);\n    };\n\n    _this.handleSizing = function () {\n      var props = _this.props;\n\n      if (props.overflowY === 'scroll-hidden') {\n        _this.setState({\n          yScrollbarWidth: _this.scroller.getYScrollbarWidth()\n        });\n      }\n\n      if (props.overflowX === 'scroll-hidden') {\n        _this.setState({\n          xScrollbarWidth: _this.scroller.getXScrollbarWidth()\n        });\n      }\n    };\n\n    return _this;\n  }\n\n  ClippedScroller.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        state = _a.state,\n        context = _a.context;\n\n    var isScrollbarOnLeft = context.isRtl && getIsRtlScrollbarOnLeft();\n    var overcomeLeft = 0;\n    var overcomeRight = 0;\n    var overcomeBottom = 0;\n\n    if (props.overflowX === 'scroll-hidden') {\n      overcomeBottom = state.xScrollbarWidth;\n    }\n\n    if (props.overflowY === 'scroll-hidden') {\n      if (state.yScrollbarWidth != null) {\n        if (isScrollbarOnLeft) {\n          overcomeLeft = state.yScrollbarWidth;\n        } else {\n          overcomeRight = state.yScrollbarWidth;\n        }\n      }\n    }\n\n    return createElement(\"div\", {\n      ref: this.elRef,\n      className: 'fc-scroller-harness' + (props.liquid ? ' fc-scroller-harness-liquid' : '')\n    }, createElement(Scroller, {\n      ref: this.handleScroller,\n      elRef: this.props.scrollerElRef,\n      overflowX: props.overflowX === 'scroll-hidden' ? 'scroll' : props.overflowX,\n      overflowY: props.overflowY === 'scroll-hidden' ? 'scroll' : props.overflowY,\n      overcomeLeft: overcomeLeft,\n      overcomeRight: overcomeRight,\n      overcomeBottom: overcomeBottom,\n      maxHeight: typeof props.maxHeight === 'number' ? props.maxHeight + (props.overflowX === 'scroll-hidden' ? state.xScrollbarWidth : 0) : '',\n      liquid: props.liquid,\n      liquidIsAbsolute: true\n    }, props.children));\n  };\n\n  ClippedScroller.prototype.componentDidMount = function () {\n    this.handleSizing();\n    this.context.addResizeHandler(this.handleSizing);\n  };\n\n  ClippedScroller.prototype.componentDidUpdate = function (prevProps) {\n    if (!isPropsEqual(prevProps, this.props)) {\n      // an external change?\n      this.handleSizing();\n    }\n  };\n\n  ClippedScroller.prototype.componentWillUnmount = function () {\n    this.context.removeResizeHandler(this.handleSizing);\n  };\n\n  ClippedScroller.prototype.needsXScrolling = function () {\n    return this.scroller.needsXScrolling();\n  };\n\n  ClippedScroller.prototype.needsYScrolling = function () {\n    return this.scroller.needsYScrolling();\n  };\n\n  return ClippedScroller;\n}(BaseComponent);\n\nvar ScrollSyncer =\n/** @class */\nfunction () {\n  function ScrollSyncer(isVertical, scrollEls) {\n    var _this = this;\n\n    this.isVertical = isVertical;\n    this.scrollEls = scrollEls;\n    this.isPaused = false;\n    this.scrollListeners = scrollEls.map(function (el) {\n      return _this.bindScroller(el);\n    });\n  }\n\n  ScrollSyncer.prototype.destroy = function () {\n    for (var _i = 0, _a = this.scrollListeners; _i < _a.length; _i++) {\n      var scrollListener = _a[_i];\n      scrollListener.destroy();\n    }\n  };\n\n  ScrollSyncer.prototype.bindScroller = function (el) {\n    var _this = this;\n\n    var _a = this,\n        scrollEls = _a.scrollEls,\n        isVertical = _a.isVertical;\n\n    var scrollListener = new ScrollListener(el);\n\n    var onScroll = function (isWheel, isTouch) {\n      if (!_this.isPaused) {\n        if (!_this.masterEl || _this.masterEl !== el && (isWheel || isTouch)) {\n          _this.assignMaster(el);\n        }\n\n        if (_this.masterEl === el) {\n          // dealing with current\n          for (var _i = 0, scrollEls_1 = scrollEls; _i < scrollEls_1.length; _i++) {\n            var otherEl = scrollEls_1[_i];\n\n            if (otherEl !== el) {\n              if (isVertical) {\n                otherEl.scrollTop = el.scrollTop;\n              } else {\n                otherEl.scrollLeft = el.scrollLeft;\n              }\n            }\n          }\n        }\n      }\n    };\n\n    var onScrollEnd = function () {\n      if (_this.masterEl === el) {\n        _this.masterEl = null;\n      }\n    };\n\n    scrollListener.emitter.on('scroll', onScroll);\n    scrollListener.emitter.on('scrollEnd', onScrollEnd);\n    return scrollListener;\n  };\n\n  ScrollSyncer.prototype.assignMaster = function (el) {\n    this.masterEl = el;\n\n    for (var _i = 0, _a = this.scrollListeners; _i < _a.length; _i++) {\n      var scrollListener = _a[_i];\n\n      if (scrollListener.el !== el) {\n        scrollListener.endScroll(); // to prevent residual scrolls from reclaiming master\n      }\n    }\n  };\n  /*\n  will normalize the scrollLeft value\n  */\n\n\n  ScrollSyncer.prototype.forceScrollLeft = function (scrollLeft) {\n    this.isPaused = true;\n\n    for (var _i = 0, _a = this.scrollListeners; _i < _a.length; _i++) {\n      var listener = _a[_i];\n      setScrollFromLeftEdge(listener.el, scrollLeft);\n    }\n\n    this.isPaused = false;\n  };\n\n  ScrollSyncer.prototype.forceScrollTop = function (top) {\n    this.isPaused = true;\n\n    for (var _i = 0, _a = this.scrollListeners; _i < _a.length; _i++) {\n      var listener = _a[_i];\n      listener.el.scrollTop = top;\n    }\n\n    this.isPaused = false;\n  };\n\n  return ScrollSyncer;\n}();\n/*\nTODO: make <ScrollGridSection> subcomponent\nNOTE: doesn't support collapsibleWidth (which is sortof a hack anyway)\n*/\n\n\nvar ScrollGrid =\n/** @class */\nfunction (_super) {\n  __extends(ScrollGrid, _super);\n\n  function ScrollGrid() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.compileColGroupStats = memoizeArraylike(compileColGroupStat, isColGroupStatsEqual);\n    _this.renderMicroColGroups = memoizeArraylike(renderMicroColGroup); // yucky to memoize VNodes, but much more efficient for consumers\n\n    _this.clippedScrollerRefs = new RefMap(); // doesn't hold non-scrolling els used just for padding\n\n    _this.scrollerElRefs = new RefMap(_this._handleScrollerEl.bind(_this));\n    _this.chunkElRefs = new RefMap(_this._handleChunkEl.bind(_this));\n    _this.getStickyScrolling = memoizeArraylike(initStickyScrolling, null, destroyStickyScrolling);\n    _this.getScrollSyncersBySection = memoizeHashlike(initScrollSyncer.bind(_this, true), null, destroyScrollSyncer);\n    _this.getScrollSyncersByColumn = memoizeHashlike(initScrollSyncer.bind(_this, false), null, destroyScrollSyncer);\n    _this.stickyScrollings = [];\n    _this.scrollSyncersBySection = {};\n    _this.scrollSyncersByColumn = {}; // for row-height-syncing\n\n    _this.rowUnstableMap = new Map(); // no need to groom. always self-cancels\n\n    _this.rowInnerMaxHeightMap = new Map();\n    _this.anyRowHeightsChanged = false;\n    _this.recentSizingCnt = 0;\n    _this.state = {\n      shrinkWidths: [],\n      forceYScrollbars: false,\n      forceXScrollbars: false,\n      scrollerClientWidths: {},\n      scrollerClientHeights: {},\n      sectionRowMaxHeights: []\n    };\n\n    _this.handleSizing = function (isForcedResize, sectionRowMaxHeightsChanged) {\n      if (!_this.allowSizing()) {\n        return;\n      }\n\n      if (!sectionRowMaxHeightsChanged) {\n        // something else changed, probably external\n        _this.anyRowHeightsChanged = true;\n      }\n\n      var otherState = {}; // if reacting to self-change of sectionRowMaxHeightsChanged, or not stable, don't do anything\n\n      if (isForcedResize || !sectionRowMaxHeightsChanged && !_this.rowUnstableMap.size) {\n        otherState.sectionRowMaxHeights = _this.computeSectionRowMaxHeights();\n      }\n\n      _this.setState(__assign(__assign({\n        shrinkWidths: _this.computeShrinkWidths()\n      }, _this.computeScrollerDims()), otherState), function () {\n        if (!_this.rowUnstableMap.size) {\n          _this.updateStickyScrolling(); // needs to happen AFTER final positioning committed to DOM\n\n        }\n      });\n    };\n\n    _this.handleRowHeightChange = function (rowEl, isStable) {\n      var _a = _this,\n          rowUnstableMap = _a.rowUnstableMap,\n          rowInnerMaxHeightMap = _a.rowInnerMaxHeightMap;\n\n      if (!isStable) {\n        rowUnstableMap.set(rowEl, true);\n      } else {\n        rowUnstableMap.delete(rowEl);\n        var innerMaxHeight = getRowInnerMaxHeight(rowEl);\n\n        if (!rowInnerMaxHeightMap.has(rowEl) || rowInnerMaxHeightMap.get(rowEl) !== innerMaxHeight) {\n          rowInnerMaxHeightMap.set(rowEl, innerMaxHeight);\n          _this.anyRowHeightsChanged = true;\n        }\n\n        if (!rowUnstableMap.size && _this.anyRowHeightsChanged) {\n          _this.anyRowHeightsChanged = false;\n\n          _this.setState({\n            sectionRowMaxHeights: _this.computeSectionRowMaxHeights()\n          });\n        }\n      }\n    };\n\n    return _this;\n  }\n\n  ScrollGrid.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        state = _a.state,\n        context = _a.context;\n\n    var shrinkWidths = state.shrinkWidths;\n    var colGroupStats = this.compileColGroupStats(props.colGroups.map(function (colGroup) {\n      return [colGroup];\n    }));\n    var microColGroupNodes = this.renderMicroColGroups(colGroupStats.map(function (stat, i) {\n      return [stat.cols, shrinkWidths[i]];\n    }));\n    var classNames = getScrollGridClassNames(props.liquid, context);\n\n    var _b = this.getDims();\n\n    _b[0];\n    _b[1]; // TODO: make DRY\n\n    var sectionConfigs = props.sections;\n    var configCnt = sectionConfigs.length;\n    var configI = 0;\n    var currentConfig;\n    var headSectionNodes = [];\n    var bodySectionNodes = [];\n    var footSectionNodes = [];\n\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'header') {\n      headSectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, true));\n      configI += 1;\n    }\n\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'body') {\n      bodySectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, false));\n      configI += 1;\n    }\n\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'footer') {\n      footSectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, true));\n      configI += 1;\n    }\n\n    var isBuggy = !getCanVGrowWithinCell(); // see NOTE in SimpleScrollGrid\n\n    var roleAttrs = {\n      role: 'rowgroup'\n    };\n    return createElement('table', {\n      ref: props.elRef,\n      role: 'grid',\n      className: classNames.join(' ')\n    }, renderMacroColGroup(colGroupStats, shrinkWidths), Boolean(!isBuggy && headSectionNodes.length) && createElement.apply(void 0, __spreadArray(['thead', roleAttrs], headSectionNodes)), Boolean(!isBuggy && bodySectionNodes.length) && createElement.apply(void 0, __spreadArray(['tbody', roleAttrs], bodySectionNodes)), Boolean(!isBuggy && footSectionNodes.length) && createElement.apply(void 0, __spreadArray(['tfoot', roleAttrs], footSectionNodes)), isBuggy && createElement.apply(void 0, __spreadArray(__spreadArray(__spreadArray(['tbody', roleAttrs], headSectionNodes), bodySectionNodes), footSectionNodes)));\n  };\n\n  ScrollGrid.prototype.renderSection = function (sectionConfig, sectionIndex, colGroupStats, microColGroupNodes, sectionRowMaxHeights, isHeader) {\n    var _this = this;\n\n    if ('outerContent' in sectionConfig) {\n      return createElement(Fragment, {\n        key: sectionConfig.key\n      }, sectionConfig.outerContent);\n    }\n\n    return createElement(\"tr\", {\n      key: sectionConfig.key,\n      role: \"presentation\",\n      className: getSectionClassNames(sectionConfig, this.props.liquid).join(' ')\n    }, sectionConfig.chunks.map(function (chunkConfig, i) {\n      return _this.renderChunk(sectionConfig, sectionIndex, colGroupStats[i], microColGroupNodes[i], chunkConfig, i, (sectionRowMaxHeights[sectionIndex] || [])[i] || [], isHeader);\n    }));\n  };\n\n  ScrollGrid.prototype.renderChunk = function (sectionConfig, sectionIndex, colGroupStat, microColGroupNode, chunkConfig, chunkIndex, rowHeights, isHeader) {\n    if ('outerContent' in chunkConfig) {\n      return createElement(Fragment, {\n        key: chunkConfig.key\n      }, chunkConfig.outerContent);\n    }\n\n    var state = this.state;\n    var scrollerClientWidths = state.scrollerClientWidths,\n        scrollerClientHeights = state.scrollerClientHeights;\n\n    var _a = this.getDims(),\n        sectionCnt = _a[0],\n        chunksPerSection = _a[1];\n\n    var index = sectionIndex * chunksPerSection + chunkIndex;\n    var sideScrollIndex = !this.context.isRtl || getIsRtlScrollbarOnLeft() ? chunksPerSection - 1 : 0;\n    var isVScrollSide = chunkIndex === sideScrollIndex;\n    var isLastSection = sectionIndex === sectionCnt - 1;\n    var forceXScrollbars = isLastSection && state.forceXScrollbars; // NOOOO can result in `null`\n\n    var forceYScrollbars = isVScrollSide && state.forceYScrollbars; // NOOOO can result in `null`\n\n    var allowXScrolling = colGroupStat && colGroupStat.allowXScrolling; // rename?\n\n    var allowYScrolling = getAllowYScrolling(this.props, sectionConfig); // rename? do in section func?\n\n    var chunkVGrow = getSectionHasLiquidHeight(this.props, sectionConfig); // do in section func?\n\n    var expandRows = sectionConfig.expandRows && chunkVGrow;\n    var tableMinWidth = colGroupStat && colGroupStat.totalColMinWidth || '';\n    var content = renderChunkContent(sectionConfig, chunkConfig, {\n      tableColGroupNode: microColGroupNode,\n      tableMinWidth: tableMinWidth,\n      clientWidth: scrollerClientWidths[index] !== undefined ? scrollerClientWidths[index] : null,\n      clientHeight: scrollerClientHeights[index] !== undefined ? scrollerClientHeights[index] : null,\n      expandRows: expandRows,\n      syncRowHeights: Boolean(sectionConfig.syncRowHeights),\n      rowSyncHeights: rowHeights,\n      reportRowHeightChange: this.handleRowHeightChange\n    }, isHeader);\n    var overflowX = forceXScrollbars ? isLastSection ? 'scroll' : 'scroll-hidden' : !allowXScrolling ? 'hidden' : isLastSection ? 'auto' : 'scroll-hidden';\n    var overflowY = forceYScrollbars ? isVScrollSide ? 'scroll' : 'scroll-hidden' : !allowYScrolling ? 'hidden' : isVScrollSide ? 'auto' : 'scroll-hidden'; // it *could* be possible to reduce DOM wrappers by only doing a ClippedScroller when allowXScrolling or allowYScrolling,\n    // but if these values were to change, the inner components would be unmounted/remounted because of the parent change.\n\n    content = createElement(ClippedScroller, {\n      ref: this.clippedScrollerRefs.createRef(index),\n      scrollerElRef: this.scrollerElRefs.createRef(index),\n      overflowX: overflowX,\n      overflowY: overflowY,\n      liquid: chunkVGrow,\n      maxHeight: sectionConfig.maxHeight\n    }, content);\n    return createElement(isHeader ? 'th' : 'td', {\n      key: chunkConfig.key,\n      ref: this.chunkElRefs.createRef(index),\n      role: 'presentation'\n    }, content);\n  };\n\n  ScrollGrid.prototype.componentDidMount = function () {\n    this.updateScrollSyncers();\n    this.handleSizing(false);\n    this.context.addResizeHandler(this.handleSizing);\n  };\n\n  ScrollGrid.prototype.componentDidUpdate = function (prevProps, prevState) {\n    this.updateScrollSyncers(); // TODO: need better solution when state contains non-sizing things\n\n    this.handleSizing(false, prevState.sectionRowMaxHeights !== this.state.sectionRowMaxHeights);\n  };\n\n  ScrollGrid.prototype.componentWillUnmount = function () {\n    this.context.removeResizeHandler(this.handleSizing);\n    this.destroyStickyScrolling();\n    this.destroyScrollSyncers();\n  };\n\n  ScrollGrid.prototype.allowSizing = function () {\n    var now = new Date();\n\n    if (!this.lastSizingDate || now.valueOf() > this.lastSizingDate.valueOf() + config.SCROLLGRID_RESIZE_INTERVAL) {\n      this.lastSizingDate = now;\n      this.recentSizingCnt = 0;\n      return true;\n    }\n\n    return (this.recentSizingCnt += 1) <= 10;\n  };\n\n  ScrollGrid.prototype.computeShrinkWidths = function () {\n    var _this = this;\n\n    var colGroupStats = this.compileColGroupStats(this.props.colGroups.map(function (colGroup) {\n      return [colGroup];\n    }));\n\n    var _a = this.getDims(),\n        sectionCnt = _a[0],\n        chunksPerSection = _a[1];\n\n    var cnt = sectionCnt * chunksPerSection;\n    var shrinkWidths = [];\n    colGroupStats.forEach(function (colGroupStat, i) {\n      if (colGroupStat.hasShrinkCol) {\n        var chunkEls = _this.chunkElRefs.collect(i, cnt, chunksPerSection); // in one col\n\n\n        shrinkWidths[i] = computeShrinkWidth(chunkEls);\n      }\n    });\n    return shrinkWidths;\n  }; // has the side effect of grooming rowInnerMaxHeightMap\n  // TODO: somehow short-circuit if there are no new height changes\n\n\n  ScrollGrid.prototype.computeSectionRowMaxHeights = function () {\n    var newHeightMap = new Map();\n\n    var _a = this.getDims(),\n        sectionCnt = _a[0],\n        chunksPerSection = _a[1];\n\n    var sectionRowMaxHeights = [];\n\n    for (var sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n      var sectionConfig = this.props.sections[sectionI];\n      var assignableHeights = []; // chunk, row\n\n      if (sectionConfig && sectionConfig.syncRowHeights) {\n        var rowHeightsByChunk = [];\n\n        for (var chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n          var index = sectionI * chunksPerSection + chunkI;\n          var rowHeights = [];\n          var chunkEl = this.chunkElRefs.currentMap[index];\n\n          if (chunkEl) {\n            rowHeights = findElements(chunkEl, '.fc-scrollgrid-sync-table tr').map(function (rowEl) {\n              var max = getRowInnerMaxHeight(rowEl);\n              newHeightMap.set(rowEl, max);\n              return max;\n            });\n          } else {\n            rowHeights = [];\n          }\n\n          rowHeightsByChunk.push(rowHeights);\n        }\n\n        var rowCnt = rowHeightsByChunk[0].length;\n        var isEqualRowCnt = true;\n\n        for (var chunkI = 1; chunkI < chunksPerSection; chunkI += 1) {\n          var isOuterContent = sectionConfig.chunks[chunkI] && sectionConfig.chunks[chunkI].outerContent !== undefined; // can be null\n\n          if (!isOuterContent && rowHeightsByChunk[chunkI].length !== rowCnt) {\n            // skip outer content\n            isEqualRowCnt = false;\n            break;\n          }\n        }\n\n        if (!isEqualRowCnt) {\n          var chunkHeightSums = [];\n\n          for (var chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n            chunkHeightSums.push(sumNumbers(rowHeightsByChunk[chunkI]) + rowHeightsByChunk[chunkI].length);\n          }\n\n          var maxTotalSum = Math.max.apply(Math, chunkHeightSums);\n\n          for (var chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n            var rowInChunkCnt = rowHeightsByChunk[chunkI].length;\n            var rowInChunkTotalHeight = maxTotalSum - rowInChunkCnt; // subtract border\n            // height of non-first row. we do this to avoid rounding, because it's unreliable within a table\n\n            var rowInChunkHeightOthers = Math.floor(rowInChunkTotalHeight / rowInChunkCnt); // whatever is leftover goes to the first row\n\n            var rowInChunkHeightFirst = rowInChunkTotalHeight - rowInChunkHeightOthers * (rowInChunkCnt - 1);\n            var rowInChunkHeights = [];\n            var row = 0;\n\n            if (row < rowInChunkCnt) {\n              rowInChunkHeights.push(rowInChunkHeightFirst);\n              row += 1;\n            }\n\n            while (row < rowInChunkCnt) {\n              rowInChunkHeights.push(rowInChunkHeightOthers);\n              row += 1;\n            }\n\n            assignableHeights.push(rowInChunkHeights);\n          }\n        } else {\n          for (var chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n            assignableHeights.push([]);\n          }\n\n          for (var row = 0; row < rowCnt; row += 1) {\n            var rowHeightsAcrossChunks = [];\n\n            for (var chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n              var h = rowHeightsByChunk[chunkI][row];\n\n              if (h != null) {\n                // protect against outerContent\n                rowHeightsAcrossChunks.push(h);\n              }\n            }\n\n            var maxHeight = Math.max.apply(Math, rowHeightsAcrossChunks);\n\n            for (var chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n              assignableHeights[chunkI].push(maxHeight);\n            }\n          }\n        }\n      }\n\n      sectionRowMaxHeights.push(assignableHeights);\n    }\n\n    this.rowInnerMaxHeightMap = newHeightMap;\n    return sectionRowMaxHeights;\n  };\n\n  ScrollGrid.prototype.computeScrollerDims = function () {\n    var scrollbarWidth = getScrollbarWidths();\n\n    var _a = this.getDims(),\n        sectionCnt = _a[0],\n        chunksPerSection = _a[1];\n\n    var sideScrollI = !this.context.isRtl || getIsRtlScrollbarOnLeft() ? chunksPerSection - 1 : 0;\n    var lastSectionI = sectionCnt - 1;\n    var currentScrollers = this.clippedScrollerRefs.currentMap;\n    var scrollerEls = this.scrollerElRefs.currentMap;\n    var forceYScrollbars = false;\n    var forceXScrollbars = false;\n    var scrollerClientWidths = {};\n    var scrollerClientHeights = {};\n\n    for (var sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n      // along edge\n      var index = sectionI * chunksPerSection + sideScrollI;\n      var scroller = currentScrollers[index];\n\n      if (scroller && scroller.needsYScrolling()) {\n        forceYScrollbars = true;\n        break;\n      }\n    }\n\n    for (var chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n      // along last row\n      var index = lastSectionI * chunksPerSection + chunkI;\n      var scroller = currentScrollers[index];\n\n      if (scroller && scroller.needsXScrolling()) {\n        forceXScrollbars = true;\n        break;\n      }\n    }\n\n    for (var sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n      for (var chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n        var index = sectionI * chunksPerSection + chunkI;\n        var scrollerEl = scrollerEls[index];\n\n        if (scrollerEl) {\n          // TODO: weird way to get this. need harness b/c doesn't include table borders\n          var harnessEl = scrollerEl.parentNode;\n          scrollerClientWidths[index] = Math.floor(harnessEl.getBoundingClientRect().width - (chunkI === sideScrollI && forceYScrollbars ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future\n          : 0));\n          scrollerClientHeights[index] = Math.floor(harnessEl.getBoundingClientRect().height - (sectionI === lastSectionI && forceXScrollbars ? scrollbarWidth.x // use global because scroller might not have scrollbars yet but will need them in future\n          : 0));\n        }\n      }\n    }\n\n    return {\n      forceYScrollbars: forceYScrollbars,\n      forceXScrollbars: forceXScrollbars,\n      scrollerClientWidths: scrollerClientWidths,\n      scrollerClientHeights: scrollerClientHeights\n    };\n  };\n\n  ScrollGrid.prototype.updateStickyScrolling = function () {\n    var isRtl = this.context.isRtl;\n    var argsByKey = this.scrollerElRefs.getAll().map(function (scrollEl) {\n      return [scrollEl, isRtl];\n    });\n    var stickyScrollings = this.getStickyScrolling(argsByKey);\n    stickyScrollings.forEach(function (stickyScrolling) {\n      return stickyScrolling.updateSize();\n    });\n    this.stickyScrollings = stickyScrollings;\n  };\n\n  ScrollGrid.prototype.destroyStickyScrolling = function () {\n    this.stickyScrollings.forEach(destroyStickyScrolling);\n  };\n\n  ScrollGrid.prototype.updateScrollSyncers = function () {\n    var _a = this.getDims(),\n        sectionCnt = _a[0],\n        chunksPerSection = _a[1];\n\n    var cnt = sectionCnt * chunksPerSection;\n    var scrollElsBySection = {};\n    var scrollElsByColumn = {};\n    var scrollElMap = this.scrollerElRefs.currentMap;\n\n    for (var sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n      var startIndex = sectionI * chunksPerSection;\n      var endIndex = startIndex + chunksPerSection;\n      scrollElsBySection[sectionI] = collectFromHash(scrollElMap, startIndex, endIndex, 1); // use the filtered\n    }\n\n    for (var col = 0; col < chunksPerSection; col += 1) {\n      scrollElsByColumn[col] = this.scrollerElRefs.collect(col, cnt, chunksPerSection); // DON'T use the filtered\n    }\n\n    this.scrollSyncersBySection = this.getScrollSyncersBySection(scrollElsBySection);\n    this.scrollSyncersByColumn = this.getScrollSyncersByColumn(scrollElsByColumn);\n  };\n\n  ScrollGrid.prototype.destroyScrollSyncers = function () {\n    mapHash(this.scrollSyncersBySection, destroyScrollSyncer);\n    mapHash(this.scrollSyncersByColumn, destroyScrollSyncer);\n  };\n\n  ScrollGrid.prototype.getChunkConfigByIndex = function (index) {\n    var chunksPerSection = this.getDims()[1];\n    var sectionI = Math.floor(index / chunksPerSection);\n    var chunkI = index % chunksPerSection;\n    var sectionConfig = this.props.sections[sectionI];\n    return sectionConfig && sectionConfig.chunks[chunkI];\n  };\n\n  ScrollGrid.prototype.forceScrollLeft = function (col, scrollLeft) {\n    var scrollSyncer = this.scrollSyncersByColumn[col];\n\n    if (scrollSyncer) {\n      scrollSyncer.forceScrollLeft(scrollLeft);\n    }\n  };\n\n  ScrollGrid.prototype.forceScrollTop = function (sectionI, scrollTop) {\n    var scrollSyncer = this.scrollSyncersBySection[sectionI];\n\n    if (scrollSyncer) {\n      scrollSyncer.forceScrollTop(scrollTop);\n    }\n  };\n\n  ScrollGrid.prototype._handleChunkEl = function (chunkEl, key) {\n    var chunkConfig = this.getChunkConfigByIndex(parseInt(key, 10));\n\n    if (chunkConfig) {\n      // null if section disappeared. bad, b/c won't null-set the elRef\n      setRef(chunkConfig.elRef, chunkEl);\n    }\n  };\n\n  ScrollGrid.prototype._handleScrollerEl = function (scrollerEl, key) {\n    var chunkConfig = this.getChunkConfigByIndex(parseInt(key, 10));\n\n    if (chunkConfig) {\n      // null if section disappeared. bad, b/c won't null-set the elRef\n      setRef(chunkConfig.scrollerElRef, scrollerEl);\n    }\n  };\n\n  ScrollGrid.prototype.getDims = function () {\n    var sectionCnt = this.props.sections.length;\n    var chunksPerSection = sectionCnt ? this.props.sections[0].chunks.length : 0;\n    return [sectionCnt, chunksPerSection];\n  };\n\n  return ScrollGrid;\n}(BaseComponent);\n\nScrollGrid.addStateEquality({\n  shrinkWidths: isArraysEqual,\n  scrollerClientWidths: isPropsEqual,\n  scrollerClientHeights: isPropsEqual\n});\n\nfunction sumNumbers(numbers) {\n  var sum = 0;\n\n  for (var _i = 0, numbers_1 = numbers; _i < numbers_1.length; _i++) {\n    var n = numbers_1[_i];\n    sum += n;\n  }\n\n  return sum;\n}\n\nfunction getRowInnerMaxHeight(rowEl) {\n  var innerHeights = findElements(rowEl, '.fc-scrollgrid-sync-inner').map(getElHeight);\n\n  if (innerHeights.length) {\n    return Math.max.apply(Math, innerHeights);\n  }\n\n  return 0;\n}\n\nfunction getElHeight(el) {\n  return el.offsetHeight; // better to deal with integers, for rounding, for PureComponent\n}\n\nfunction renderMacroColGroup(colGroupStats, shrinkWidths) {\n  var children = colGroupStats.map(function (colGroupStat, i) {\n    var width = colGroupStat.width;\n\n    if (width === 'shrink') {\n      width = colGroupStat.totalColWidth + sanitizeShrinkWidth(shrinkWidths[i]) + 1; // +1 for border :(\n    }\n\n    return (// eslint-disable-next-line react/jsx-key\n      createElement(\"col\", {\n        style: {\n          width: width\n        }\n      })\n    );\n  });\n  return createElement.apply(void 0, __spreadArray(['colgroup', {}], children));\n}\n\nfunction compileColGroupStat(colGroupConfig) {\n  var totalColWidth = sumColProp(colGroupConfig.cols, 'width'); // excludes \"shrink\"\n\n  var totalColMinWidth = sumColProp(colGroupConfig.cols, 'minWidth');\n  var hasShrinkCol = hasShrinkWidth(colGroupConfig.cols);\n  var allowXScrolling = colGroupConfig.width !== 'shrink' && Boolean(totalColWidth || totalColMinWidth || hasShrinkCol);\n  return {\n    hasShrinkCol: hasShrinkCol,\n    totalColWidth: totalColWidth,\n    totalColMinWidth: totalColMinWidth,\n    allowXScrolling: allowXScrolling,\n    cols: colGroupConfig.cols,\n    width: colGroupConfig.width\n  };\n}\n\nfunction sumColProp(cols, propName) {\n  var total = 0;\n\n  for (var _i = 0, cols_1 = cols; _i < cols_1.length; _i++) {\n    var col = cols_1[_i];\n    var val = col[propName];\n\n    if (typeof val === 'number') {\n      total += val * (col.span || 1);\n    }\n  }\n\n  return total;\n}\n\nvar COL_GROUP_STAT_EQUALITY = {\n  cols: isColPropsEqual\n};\n\nfunction isColGroupStatsEqual(stat0, stat1) {\n  return compareObjs(stat0, stat1, COL_GROUP_STAT_EQUALITY);\n} // for memoizers...\n\n\nfunction initScrollSyncer(isVertical) {\n  var scrollEls = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    scrollEls[_i - 1] = arguments[_i];\n  }\n\n  return new ScrollSyncer(isVertical, scrollEls);\n}\n\nfunction destroyScrollSyncer(scrollSyncer) {\n  scrollSyncer.destroy();\n}\n\nfunction initStickyScrolling(scrollEl, isRtl) {\n  return new StickyScrolling(scrollEl, isRtl);\n}\n\nfunction destroyStickyScrolling(stickyScrolling) {\n  stickyScrolling.destroy();\n}\n\nvar main = createPlugin({\n  deps: [premiumCommonPlugin],\n  scrollGridImpl: ScrollGrid\n});\nconfig.SCROLLGRID_RESIZE_INTERVAL = 500;\nexport default main;\nexport { ScrollGrid, setScrollFromLeftEdge };","map":{"version":3,"mappings":"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","names":["WHEEL_EVENT_NAMES","split","el","Emitter","DelayedRunner","_handleWheelWaited","bind","_handleScrollWaited","_this","startScroll","emitter","trigger","isRecentlyWheeled","isTouching","isRecentlyScrolled","scrollWaiter","request","wheelWaiter","endScroll","addEventListener","handleScroll","handleTouchStart","passive","handleTouchEnd","_i","eventName","handleWheel","ScrollListener","removeEventListener","isScrolling","clear","getScrollCanvasOrigin","scrollEl","rect","getBoundingClientRect","edges","computeEdges","left","borderLeft","scrollbarLeft","getScrollFromLeftEdge","top","borderTop","scrollTop","scrollLeft","computedStyles","window","getComputedStyle","direction","getRtlScrollSystem","scrollWidth","clientWidth","setScrollFromLeftEdge","_rtlScrollSystem","detectRtlScrollSystem","document","createElement","style","position","width","height","overflow","fontSize","innerHTML","body","appendChild","system","removeElement","IS_MS_EDGE","navigator","test","userAgent","STICKY_SELECTOR","isRtl","els","findElements","elGeoms","queryElGeoms","viewportWidth","viewportHeight","clientHeight","usingRelative","elDestinations","computeElDestinations","assignRelativePositions","assignStickyPositions","getStickySupported","listener","on","updateSize","StickyScrolling","destroy","canvasOrigin","parentBound","translateRect","computeInnerRect","parentNode","elRect","textAlign","naturalBound","parseFloat","push","elWidth","elHeight","viewportTop","viewportLeft","viewportRight","map","elGeom","destLeft","destTop","Math","min","right","max","bottom","forEach","i","parentWidth","parentHeight","applyStyle","_isStickySupported","computeStickySupported","val","__extends","createRef","xScrollbarWidth","yScrollbarWidth","scroller","setRef","props","scrollerRef","overflowY","setState","getYScrollbarWidth","overflowX","getXScrollbarWidth","ClippedScroller","state","context","isScrollbarOnLeft","getIsRtlScrollbarOnLeft","overcomeLeft","overcomeRight","overcomeBottom","ref","elRef","className","liquid","Scroller","handleScroller","scrollerElRef","maxHeight","liquidIsAbsolute","children","handleSizing","addResizeHandler","prevProps","isPropsEqual","removeResizeHandler","needsXScrolling","needsYScrolling","BaseComponent","isVertical","scrollEls","scrollListeners","bindScroller","ScrollSyncer","scrollListener","onScroll","isWheel","isTouch","isPaused","masterEl","assignMaster","otherEl","onScrollEnd","memoizeArraylike","compileColGroupStat","isColGroupStatsEqual","renderMicroColGroup","RefMap","_handleScrollerEl","_handleChunkEl","initStickyScrolling","destroyStickyScrolling","memoizeHashlike","initScrollSyncer","destroyScrollSyncer","Map","shrinkWidths","forceYScrollbars","forceXScrollbars","scrollerClientWidths","scrollerClientHeights","sectionRowMaxHeights","isForcedResize","sectionRowMaxHeightsChanged","allowSizing","anyRowHeightsChanged","otherState","rowUnstableMap","size","computeSectionRowMaxHeights","__assign","computeShrinkWidths","computeScrollerDims","updateStickyScrolling","rowEl","isStable","rowInnerMaxHeightMap","set","delete","innerMaxHeight","getRowInnerMaxHeight","has","get","ScrollGrid","colGroupStats","compileColGroupStats","colGroups","colGroup","microColGroupNodes","renderMicroColGroups","stat","cols","classNames","getScrollGridClassNames","_b","getDims","sectionConfigs","sections","configCnt","length","configI","currentConfig","headSectionNodes","bodySectionNodes","footSectionNodes","type","renderSection","isBuggy","getCanVGrowWithinCell","roleAttrs","role","join","renderMacroColGroup","Boolean","__spreadArray","sectionConfig","sectionIndex","isHeader","Fragment","key","outerContent","getSectionClassNames","chunks","chunkConfig","renderChunk","colGroupStat","microColGroupNode","chunkIndex","rowHeights","sectionCnt","chunksPerSection","index","sideScrollIndex","isVScrollSide","isLastSection","allowXScrolling","allowYScrolling","getAllowYScrolling","chunkVGrow","getSectionHasLiquidHeight","expandRows","tableMinWidth","totalColMinWidth","content","renderChunkContent","tableColGroupNode","undefined","syncRowHeights","rowSyncHeights","reportRowHeightChange","handleRowHeightChange","clippedScrollerRefs","scrollerElRefs","chunkElRefs","updateScrollSyncers","prevState","destroyScrollSyncers","now","Date","lastSizingDate","valueOf","config","SCROLLGRID_RESIZE_INTERVAL","recentSizingCnt","cnt","hasShrinkCol","chunkEls","collect","computeShrinkWidth","newHeightMap","sectionI","assignableHeights","rowHeightsByChunk","chunkI","chunkEl","currentMap","rowCnt","isEqualRowCnt","isOuterContent","chunkHeightSums","sumNumbers","maxTotalSum","apply","rowInChunkCnt","rowInChunkTotalHeight","rowInChunkHeightOthers","floor","rowInChunkHeightFirst","rowInChunkHeights","row","rowHeightsAcrossChunks","h","scrollbarWidth","getScrollbarWidths","sideScrollI","lastSectionI","currentScrollers","scrollerEls","scrollerEl","harnessEl","y","x","argsByKey","getAll","stickyScrollings","getStickyScrolling","stickyScrolling","scrollElsBySection","scrollElsByColumn","scrollElMap","startIndex","endIndex","collectFromHash","col","scrollSyncersBySection","getScrollSyncersBySection","scrollSyncersByColumn","getScrollSyncersByColumn","mapHash","scrollSyncer","forceScrollLeft","forceScrollTop","getChunkConfigByIndex","parseInt","addStateEquality","isArraysEqual","numbers","sum","n","innerHeights","getElHeight","offsetHeight","totalColWidth","sanitizeShrinkWidth","colGroupConfig","sumColProp","hasShrinkWidth","propName","total","span","COL_GROUP_STAT_EQUALITY","isColPropsEqual","stat0","stat1","compareObjs","createPlugin","deps","premiumCommonPlugin","scrollGridImpl"],"sources":["src/ScrollListener.ts","src/scroll-left-norm.tsx","src/StickyScrolling.ts","src/ClippedScroller.tsx","src/ScrollSyncer.ts","src/ScrollGrid.tsx","src/main.ts"],"sourcesContent":["import { Emitter, DelayedRunner } from '@fullcalendar/common'\n\nconst WHEEL_EVENT_NAMES = 'wheel mousewheel DomMouseScroll MozMousePixelScroll'.split(' ')\n\n/*\nALSO, with the ability to disable touch\n*/\nexport class ScrollListener {\n  emitter = new Emitter()\n  private isScrolling = false\n  private isTouching = false // user currently has finger down?\n  private isRecentlyWheeled = false\n  private isRecentlyScrolled = false\n  private wheelWaiter = new DelayedRunner(this._handleWheelWaited.bind(this))\n  private scrollWaiter = new DelayedRunner(this._handleScrollWaited.bind(this))\n\n  constructor(public el: HTMLElement) {\n    el.addEventListener('scroll', this.handleScroll)\n    el.addEventListener('touchstart', this.handleTouchStart, { passive: true })\n    el.addEventListener('touchend', this.handleTouchEnd)\n\n    for (let eventName of WHEEL_EVENT_NAMES) {\n      el.addEventListener(eventName, this.handleWheel)\n    }\n  }\n\n  destroy() {\n    let { el } = this\n    el.removeEventListener('scroll', this.handleScroll)\n    el.removeEventListener('touchstart', this.handleTouchStart, { passive: true } as AddEventListenerOptions)\n    el.removeEventListener('touchend', this.handleTouchEnd)\n\n    for (let eventName of WHEEL_EVENT_NAMES) {\n      el.removeEventListener(eventName, this.handleWheel)\n    }\n  }\n\n  // Start / Stop\n  // ----------------------------------------------------------------------------------------------\n\n  private startScroll() {\n    if (!this.isScrolling) {\n      this.isScrolling = true\n      this.emitter.trigger('scrollStart', this.isRecentlyWheeled, this.isTouching)\n    }\n  }\n\n  endScroll() {\n    if (this.isScrolling) {\n      this.emitter.trigger('scrollEnd')\n      this.isScrolling = false\n      this.isRecentlyScrolled = true\n      this.isRecentlyWheeled = false\n      this.scrollWaiter.clear()\n      this.wheelWaiter.clear()\n    }\n  }\n\n  // Handlers\n  // ----------------------------------------------------------------------------------------------\n\n  handleScroll = () => {\n    this.startScroll()\n    this.emitter.trigger('scroll', this.isRecentlyWheeled, this.isTouching)\n    this.isRecentlyScrolled = true\n    this.scrollWaiter.request(500)\n  }\n\n  _handleScrollWaited() {\n    this.isRecentlyScrolled = false\n\n    // only end the scroll if not currently touching.\n    // if touching, the scrolling will end later, on touchend.\n    if (!this.isTouching) {\n      this.endScroll() // won't fire if already ended\n    }\n  }\n\n  // will fire *before* the scroll event is fired (might not cause a scroll)\n  handleWheel = () => {\n    this.isRecentlyWheeled = true\n    this.wheelWaiter.request(500)\n  }\n\n  _handleWheelWaited() {\n    this.isRecentlyWheeled = false\n  }\n\n  // will fire *before* the scroll event is fired (might not cause a scroll)\n  handleTouchStart = () => {\n    this.isTouching = true\n  }\n\n  handleTouchEnd = () => {\n    this.isTouching = false\n\n    // if the user ended their touch, and the scroll area wasn't moving,\n    // we consider this to be the end of the scroll.\n    if (!this.isRecentlyScrolled) {\n      this.endScroll() // won't fire if already ended\n    }\n  }\n}\n","import { removeElement, computeEdges } from '@fullcalendar/common'\n\n// TODO: assume the el has no borders?\nexport function getScrollCanvasOrigin(scrollEl: HTMLElement) { // best place for this?\n  let rect = scrollEl.getBoundingClientRect()\n  let edges = computeEdges(scrollEl) // TODO: pass in isRtl?\n\n  return {\n    left: rect.left + edges.borderLeft + edges.scrollbarLeft - getScrollFromLeftEdge(scrollEl),\n    top: rect.top + edges.borderTop - scrollEl.scrollTop,\n  }\n}\n\nexport function getScrollFromLeftEdge(el: HTMLElement) {\n  let scrollLeft = el.scrollLeft\n  let computedStyles = window.getComputedStyle(el) // TODO: pass in isRtl instead?\n\n  if (computedStyles.direction === 'rtl') {\n    switch (getRtlScrollSystem()) {\n      case 'negative':\n        scrollLeft *= -1 // convert to 'reverse'. fall through...\n      case 'reverse': // scrollLeft is distance between scrollframe's right edge scrollcanvas's right edge\n        scrollLeft = el.scrollWidth - scrollLeft - el.clientWidth\n    }\n  }\n\n  return scrollLeft\n}\n\nexport function setScrollFromLeftEdge(el: HTMLElement, scrollLeft: number) {\n  let computedStyles = window.getComputedStyle(el) // TODO: pass in isRtl instead?\n\n  if (computedStyles.direction === 'rtl') {\n    switch (getRtlScrollSystem()) {\n      case 'reverse':\n        scrollLeft = el.scrollWidth - scrollLeft\n        break\n      case 'negative':\n        scrollLeft = -(el.scrollWidth - scrollLeft)\n        break\n    }\n  }\n\n  el.scrollLeft = scrollLeft\n}\n\n// Horizontal Scroll System Detection\n// ----------------------------------------------------------------------------------------------\n\nlet _rtlScrollSystem\n\nfunction getRtlScrollSystem() {\n  return _rtlScrollSystem || (_rtlScrollSystem = detectRtlScrollSystem())\n}\n\nfunction detectRtlScrollSystem() {\n  let el = document.createElement('div')\n  el.style.position = 'absolute'\n  el.style.top = '-1000px'\n  el.style.width = '1px'\n  el.style.height = '1px'\n  el.style.overflow = 'scroll'\n  el.style.direction = 'rtl'\n  el.style.fontSize = '100px'\n  el.innerHTML = 'A'\n\n  document.body.appendChild(el)\n\n  let system\n  if (el.scrollLeft > 0) {\n    system = 'positive' // scroll is a positive number from the left edge\n  } else {\n    el.scrollLeft = 1\n    if (el.scrollLeft > 0) {\n      system = 'reverse' // scroll is a positive number from the right edge\n    } else {\n      system = 'negative' // scroll is a negative number from the right edge\n    }\n  }\n\n  removeElement(el)\n  return system\n}\n","import {\n  applyStyle,\n  translateRect, Rect, Point,\n  findElements,\n  computeInnerRect,\n  CssDimValue,\n  removeElement,\n} from '@fullcalendar/common'\nimport { ScrollListener } from './ScrollListener'\nimport { getScrollCanvasOrigin, getScrollFromLeftEdge } from './scroll-left-norm'\n\ninterface ElementGeom {\n  parentBound: Rect // relative to the canvas origin\n  naturalBound: Rect | null // of the el itself\n  elWidth: number\n  elHeight: number\n  textAlign: string\n}\n\nconst IS_MS_EDGE = typeof navigator !== 'undefined' && /Edge/.test(navigator.userAgent) // TODO: what about Chromeum-based Edge?\nconst STICKY_SELECTOR = '.fc-sticky'\n\n/*\nuseful beyond the native position:sticky for these reasons:\n- support in IE11\n- nice centering support\n\nREQUIREMENT: fc-sticky elements, if the fc-sticky className is taken away, should NOT have relative or absolute positioning.\nThis is because we attach the coords with JS, and the VDOM might take away the fc-sticky class but doesn't know kill the positioning.\n\nTODO: don't query text-align:center. isn't compatible with flexbox centering. instead, check natural X coord within parent container\n*/\nexport class StickyScrolling {\n  listener?: ScrollListener\n  usingRelative: boolean | null = null\n\n  constructor(\n    private scrollEl: HTMLElement,\n    private isRtl: boolean,\n  ) {\n    this.usingRelative =\n      !getStickySupported() || // IE11\n      // https://stackoverflow.com/questions/56835658/in-microsoft-edge-sticky-positioning-doesnt-work-when-combined-with-dir-rtl\n      (IS_MS_EDGE && isRtl)\n\n    if (this.usingRelative) {\n      this.listener = new ScrollListener(scrollEl)\n      this.listener.emitter.on('scrollEnd', this.updateSize)\n    }\n  }\n\n  destroy() {\n    if (this.listener) {\n      this.listener.destroy()\n    }\n  }\n\n  updateSize = () => {\n    let { scrollEl } = this\n    let els = findElements(scrollEl, STICKY_SELECTOR)\n    let elGeoms = this.queryElGeoms(els)\n    let viewportWidth = scrollEl.clientWidth\n    let viewportHeight = scrollEl.clientHeight\n\n    if (this.usingRelative) {\n      let elDestinations = this.computeElDestinations(elGeoms, viewportWidth) // read before prepPositioning\n\n      assignRelativePositions(els, elGeoms, elDestinations, viewportWidth, viewportHeight)\n    } else {\n      assignStickyPositions(els, elGeoms, viewportWidth)\n    }\n  }\n\n  queryElGeoms(els: HTMLElement[]): ElementGeom[] {\n    let { scrollEl, isRtl } = this\n    let canvasOrigin = getScrollCanvasOrigin(scrollEl)\n    let elGeoms: ElementGeom[] = []\n\n    for (let el of els) {\n      let parentBound = translateRect(\n        computeInnerRect(el.parentNode as HTMLElement, true, true), // weird way to call this!!!\n        -canvasOrigin.left,\n        -canvasOrigin.top,\n      )\n\n      let elRect = el.getBoundingClientRect()\n      let computedStyles = window.getComputedStyle(el)\n      let textAlign = window.getComputedStyle(el.parentNode as HTMLElement).textAlign // ask the parent\n      let naturalBound = null\n\n      if (textAlign === 'start') {\n        textAlign = isRtl ? 'right' : 'left'\n      } else if (textAlign === 'end') {\n        textAlign = isRtl ? 'left' : 'right'\n      }\n\n      if (computedStyles.position !== 'sticky') {\n        naturalBound = translateRect(\n          elRect,\n          -canvasOrigin.left - (parseFloat(computedStyles.left) || 0), // could be 'auto'\n          -canvasOrigin.top - (parseFloat(computedStyles.top) || 0),\n        )\n      }\n\n      elGeoms.push({\n        parentBound,\n        naturalBound,\n        elWidth: elRect.width,\n        elHeight: elRect.height,\n        textAlign,\n      })\n    }\n\n    return elGeoms\n  }\n\n  // only for IE\n  computeElDestinations(elGeoms: ElementGeom[], viewportWidth: number): Point[] {\n    let { scrollEl } = this\n    let viewportTop = scrollEl.scrollTop\n    let viewportLeft = getScrollFromLeftEdge(scrollEl)\n    let viewportRight = viewportLeft + viewportWidth\n\n    return elGeoms.map((elGeom) => {\n      let { elWidth, elHeight, parentBound, naturalBound } = elGeom\n      let destLeft // relative to canvas topleft\n      let destTop // \"\n\n      switch (elGeom.textAlign) {\n        case 'left':\n          destLeft = viewportLeft\n          break\n        case 'right':\n          destLeft = viewportRight - elWidth\n          break\n        case 'center':\n          destLeft = (viewportLeft + viewportRight) / 2 - elWidth / 2 /// noooo, use half-width insteadddddddd\n          break\n      }\n\n      destLeft = Math.min(destLeft, parentBound.right - elWidth)\n      destLeft = Math.max(destLeft, parentBound.left)\n\n      destTop = viewportTop\n      destTop = Math.min(destTop, parentBound.bottom - elHeight)\n      destTop = Math.max(destTop, naturalBound.top) // better to use natural top for upper bound\n\n      return { left: destLeft, top: destTop }\n    })\n  }\n}\n\nfunction assignRelativePositions(\n  els: HTMLElement[],\n  elGeoms: ElementGeom[],\n  elDestinations: Point[],\n  viewportWidth: number,\n  viewportHeight: number,\n) {\n  els.forEach((el, i) => {\n    let { naturalBound, parentBound } = elGeoms[i]\n    let parentWidth = parentBound.right - parentBound.left\n    let parentHeight = parentBound.bottom - parentBound.bottom\n    let left: CssDimValue\n    let top: CssDimValue\n\n    if (\n      parentWidth > viewportWidth ||\n      parentHeight > viewportHeight\n    ) {\n      left = elDestinations[i].left - naturalBound.left\n      top = elDestinations[i].top - naturalBound.top\n    } else { // if parent container can be completely in view, we don't need stickiness\n      left = ''\n      top = ''\n    }\n\n    applyStyle(el, {\n      position: 'relative',\n      left,\n      right: -left, // for rtl\n      top,\n    })\n  })\n}\n\nfunction assignStickyPositions(els: HTMLElement[], elGeoms: ElementGeom[], viewportWidth: number) {\n  els.forEach((el, i) => {\n    let { textAlign, elWidth, parentBound } = elGeoms[i]\n    let parentWidth = parentBound.right - parentBound.left\n    let left: CssDimValue\n\n    if (\n      textAlign === 'center' &&\n      parentWidth > viewportWidth\n    ) {\n      left = (viewportWidth - elWidth) / 2\n    } else { // if parent container can be completely in view, we don't need stickiness\n      left = ''\n    }\n\n    applyStyle(el, { // will already have fc-sticky class which makes it sticky\n      left,\n      right: left, // for when centered\n      top: 0,\n    })\n  })\n}\n\nlet _isStickySupported\n\nfunction getStickySupported() {\n  if (_isStickySupported == null) {\n    _isStickySupported = computeStickySupported()\n  }\n  return _isStickySupported\n}\n\nfunction computeStickySupported() {\n  let el = document.createElement('div')\n  el.style.position = 'sticky'\n  document.body.appendChild(el)\n  let val = window.getComputedStyle(el).position\n  removeElement(el)\n  return val === 'sticky'\n}\n","import {\n  createElement, ComponentChildren, createRef, Ref, BaseComponent, setRef,\n  ScrollerLike,\n  Scroller, OverflowValue,\n  getIsRtlScrollbarOnLeft,\n  isPropsEqual,\n} from '@fullcalendar/common'\n\nexport type ClippedOverflowValue = OverflowValue | 'scroll-hidden'\n\nexport interface ClippedScrollerProps {\n  overflowX: ClippedOverflowValue\n  overflowY: ClippedOverflowValue\n  liquid: boolean\n  maxHeight?: number // incompatible with liquid\n  children?: ComponentChildren\n  scrollerRef?: Ref<Scroller>\n  scrollerElRef?: Ref<HTMLElement>\n}\n\ninterface ClippedScrollerState {\n  yScrollbarWidth?: number\n  xScrollbarWidth?: number\n}\n\nexport class ClippedScroller extends BaseComponent<ClippedScrollerProps, ClippedScrollerState> implements ScrollerLike {\n  private elRef = createRef<HTMLDivElement>()\n  private scroller: Scroller\n\n  state = {\n    xScrollbarWidth: 0,\n    yScrollbarWidth: 0,\n  }\n\n  render() {\n    let { props, state, context } = this\n    let isScrollbarOnLeft = context.isRtl && getIsRtlScrollbarOnLeft()\n    let overcomeLeft = 0\n    let overcomeRight = 0\n    let overcomeBottom = 0\n\n    if (props.overflowX === 'scroll-hidden') {\n      overcomeBottom = state.xScrollbarWidth\n    }\n\n    if (props.overflowY === 'scroll-hidden') {\n      if (state.yScrollbarWidth != null) {\n        if (isScrollbarOnLeft) {\n          overcomeLeft = state.yScrollbarWidth\n        } else {\n          overcomeRight = state.yScrollbarWidth\n        }\n      }\n    }\n\n    return (\n      <div\n        ref={this.elRef}\n        className={'fc-scroller-harness' + (props.liquid ? ' fc-scroller-harness-liquid' : '')}\n      >\n        <Scroller\n          ref={this.handleScroller}\n          elRef={this.props.scrollerElRef}\n          overflowX={props.overflowX === 'scroll-hidden' ? 'scroll' : props.overflowX}\n          overflowY={props.overflowY === 'scroll-hidden' ? 'scroll' : props.overflowY}\n          overcomeLeft={overcomeLeft}\n          overcomeRight={overcomeRight}\n          overcomeBottom={overcomeBottom}\n          maxHeight={\n            typeof props.maxHeight === 'number'\n              ? (props.maxHeight + (props.overflowX === 'scroll-hidden' ? state.xScrollbarWidth : 0))\n              : ''\n          }\n          liquid={props.liquid}\n          liquidIsAbsolute\n        >\n          {props.children}\n        </Scroller>\n      </div>\n    )\n  }\n\n  handleScroller = (scroller: Scroller) => {\n    this.scroller = scroller\n    setRef(this.props.scrollerRef, scroller)\n  }\n\n  componentDidMount() {\n    this.handleSizing()\n    this.context.addResizeHandler(this.handleSizing)\n  }\n\n  componentDidUpdate(prevProps: ClippedScrollerProps) {\n    if (!isPropsEqual(prevProps, this.props)) { // an external change?\n      this.handleSizing()\n    }\n  }\n\n  componentWillUnmount() {\n    this.context.removeResizeHandler(this.handleSizing)\n  }\n\n  handleSizing = () => {\n    let { props } = this\n\n    if (props.overflowY === 'scroll-hidden') {\n      this.setState({ yScrollbarWidth: this.scroller.getYScrollbarWidth() })\n    }\n\n    if (props.overflowX === 'scroll-hidden') {\n      this.setState({ xScrollbarWidth: this.scroller.getXScrollbarWidth() })\n    }\n  }\n\n  needsXScrolling() {\n    return this.scroller.needsXScrolling()\n  }\n\n  needsYScrolling() {\n    return this.scroller.needsYScrolling()\n  }\n}\n","import { ScrollListener } from './ScrollListener'\nimport { setScrollFromLeftEdge } from './scroll-left-norm'\n\nexport class ScrollSyncer {\n  private masterEl: HTMLElement\n  private scrollListeners: ScrollListener[]\n  private isPaused: boolean = false\n\n  constructor(\n    private isVertical: boolean,\n    private scrollEls: HTMLElement[],\n  ) {\n    this.scrollListeners = scrollEls.map((el) => this.bindScroller(el))\n  }\n\n  destroy() {\n    for (let scrollListener of this.scrollListeners) {\n      scrollListener.destroy()\n    }\n  }\n\n  bindScroller(el: HTMLElement) {\n    let { scrollEls, isVertical } = this\n    let scrollListener = new ScrollListener(el)\n\n    const onScroll = (isWheel, isTouch) => {\n      if (!this.isPaused) {\n        if (!this.masterEl || (this.masterEl !== el && (isWheel || isTouch))) {\n          this.assignMaster(el)\n        }\n\n        if (this.masterEl === el) { // dealing with current\n          for (let otherEl of scrollEls) {\n            if (otherEl !== el) {\n              if (isVertical) {\n                otherEl.scrollTop = el.scrollTop\n              } else {\n                otherEl.scrollLeft = el.scrollLeft\n              }\n            }\n          }\n        }\n      }\n    }\n\n    const onScrollEnd = () => {\n      if (this.masterEl === el) {\n        this.masterEl = null\n      }\n    }\n\n    scrollListener.emitter.on('scroll', onScroll)\n    scrollListener.emitter.on('scrollEnd', onScrollEnd)\n\n    return scrollListener\n  }\n\n  assignMaster(el: HTMLElement) {\n    this.masterEl = el\n\n    for (let scrollListener of this.scrollListeners) {\n      if (scrollListener.el !== el) {\n        scrollListener.endScroll() // to prevent residual scrolls from reclaiming master\n      }\n    }\n  }\n\n  /*\n  will normalize the scrollLeft value\n  */\n  forceScrollLeft(scrollLeft: number) {\n    this.isPaused = true\n\n    for (let listener of this.scrollListeners) {\n      setScrollFromLeftEdge(listener.el, scrollLeft)\n    }\n\n    this.isPaused = false\n  }\n\n  forceScrollTop(top: number) {\n    this.isPaused = true\n\n    for (let listener of this.scrollListeners) {\n      listener.el.scrollTop = top\n    }\n\n    this.isPaused = false\n  }\n}\n","import {\n  createElement, VNode, Fragment,\n  BaseComponent,\n  isArraysEqual,\n  findElements,\n  mapHash,\n  RefMap,\n  ColProps, CssDimValue, hasShrinkWidth, renderMicroColGroup,\n  ScrollGridProps, ScrollGridSectionConfig, ColGroupConfig,\n  getScrollGridClassNames, getSectionClassNames, getSectionHasLiquidHeight, getAllowYScrolling, renderChunkContent, computeShrinkWidth,\n  getIsRtlScrollbarOnLeft,\n  setRef,\n  sanitizeShrinkWidth,\n  isPropsEqual,\n  compareObjs,\n  isColPropsEqual,\n  getScrollbarWidths,\n  memoizeArraylike,\n  collectFromHash,\n  memoizeHashlike,\n  ScrollGridChunkConfig,\n  getCanVGrowWithinCell,\n  config,\n} from '@fullcalendar/common'\nimport { StickyScrolling } from './StickyScrolling'\nimport { ClippedScroller, ClippedOverflowValue } from './ClippedScroller'\nimport { ScrollSyncer } from './ScrollSyncer'\n\ninterface ScrollGridState {\n  shrinkWidths: number[] // for only one col within each vertical stack of chunks\n  forceYScrollbars: boolean // null means not computed yet\n  forceXScrollbars: boolean // \"\n  scrollerClientWidths: { [index: string]: number } // why not use array?\n  scrollerClientHeights: { [index: string]: number }\n  sectionRowMaxHeights: number[][][]\n}\n\ninterface ColGroupStat {\n  hasShrinkCol: boolean\n  totalColWidth: number\n  totalColMinWidth: number\n  allowXScrolling: boolean\n  width?: CssDimValue\n  cols: ColProps[]\n}\n\n/*\nTODO: make <ScrollGridSection> subcomponent\nNOTE: doesn't support collapsibleWidth (which is sortof a hack anyway)\n*/\nexport class ScrollGrid extends BaseComponent<ScrollGridProps, ScrollGridState> {\n  private compileColGroupStats = memoizeArraylike(compileColGroupStat, isColGroupStatsEqual)\n  private renderMicroColGroups = memoizeArraylike(renderMicroColGroup) // yucky to memoize VNodes, but much more efficient for consumers\n  private clippedScrollerRefs = new RefMap<ClippedScroller>()\n\n  // doesn't hold non-scrolling els used just for padding\n  private scrollerElRefs = new RefMap<HTMLElement>(this._handleScrollerEl.bind(this))\n\n  private chunkElRefs = new RefMap<HTMLTableCellElement>(this._handleChunkEl.bind(this))\n  private getStickyScrolling = memoizeArraylike(initStickyScrolling, null, destroyStickyScrolling)\n  private getScrollSyncersBySection = memoizeHashlike(initScrollSyncer.bind(this, true), null, destroyScrollSyncer)\n  private getScrollSyncersByColumn = memoizeHashlike(initScrollSyncer.bind(this, false), null, destroyScrollSyncer)\n  private stickyScrollings: StickyScrolling[] = []\n  private scrollSyncersBySection: { [sectionI: string]: ScrollSyncer } = {}\n  private scrollSyncersByColumn: { [columnI: string]: ScrollSyncer } = {}\n\n  // for row-height-syncing\n  private rowUnstableMap = new Map<HTMLTableRowElement, boolean>() // no need to groom. always self-cancels\n  private rowInnerMaxHeightMap = new Map<HTMLTableRowElement, number>()\n  private anyRowHeightsChanged = false\n\n  private lastSizingDate: Date\n  private recentSizingCnt = 0\n\n  state: ScrollGridState = {\n    shrinkWidths: [],\n    forceYScrollbars: false,\n    forceXScrollbars: false,\n    scrollerClientWidths: {},\n    scrollerClientHeights: {},\n    sectionRowMaxHeights: [],\n  }\n\n  render(): VNode {\n    let { props, state, context } = this\n    let { shrinkWidths } = state\n\n    let colGroupStats = this.compileColGroupStats(props.colGroups.map((colGroup) => [colGroup]))\n    let microColGroupNodes = this.renderMicroColGroups(colGroupStats.map((stat, i) => [stat.cols, shrinkWidths[i]]))\n    let classNames = getScrollGridClassNames(props.liquid, context)\n\n    // yuck\n    let indices: [ number, number ][] = []\n    let [sectionCnt, chunksPerSection] = this.getDims()\n    for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n      for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n        indices.push([sectionI, chunkI])\n      }\n    }\n\n    // TODO: make DRY\n    let sectionConfigs = props.sections\n    let configCnt = sectionConfigs.length\n    let configI = 0\n    let currentConfig: ScrollGridSectionConfig\n    let headSectionNodes: VNode[] = []\n    let bodySectionNodes: VNode[] = []\n    let footSectionNodes: VNode[] = []\n\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'header') {\n      headSectionNodes.push(this.renderSection(\n        currentConfig,\n        configI,\n        colGroupStats,\n        microColGroupNodes,\n        state.sectionRowMaxHeights,\n        true,\n      ))\n      configI += 1\n    }\n\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'body') {\n      bodySectionNodes.push(this.renderSection(\n        currentConfig,\n        configI,\n        colGroupStats,\n        microColGroupNodes,\n        state.sectionRowMaxHeights,\n        false,\n      ))\n      configI += 1\n    }\n\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'footer') {\n      footSectionNodes.push(this.renderSection(\n        currentConfig,\n        configI,\n        colGroupStats,\n        microColGroupNodes,\n        state.sectionRowMaxHeights,\n        true,\n      ))\n      configI += 1\n    }\n\n    const isBuggy = !getCanVGrowWithinCell() // see NOTE in SimpleScrollGrid\n    const roleAttrs = { role: 'rowgroup' }\n\n    return createElement(\n      'table',\n      {\n        ref: props.elRef,\n        role: 'grid',\n        className: classNames.join(' '),\n      },\n      renderMacroColGroup(colGroupStats, shrinkWidths),\n      Boolean(!isBuggy && headSectionNodes.length) && createElement('thead', roleAttrs, ...headSectionNodes),\n      Boolean(!isBuggy && bodySectionNodes.length) && createElement('tbody', roleAttrs, ...bodySectionNodes),\n      Boolean(!isBuggy && footSectionNodes.length) && createElement('tfoot', roleAttrs, ...footSectionNodes),\n      isBuggy && createElement('tbody', roleAttrs, ...headSectionNodes, ...bodySectionNodes, ...footSectionNodes),\n    )\n  }\n\n  renderSection(\n    sectionConfig: ScrollGridSectionConfig,\n    sectionIndex: number,\n    colGroupStats: ColGroupStat[],\n    microColGroupNodes: VNode[],\n    sectionRowMaxHeights: number[][][],\n    isHeader: boolean,\n  ): VNode {\n    if ('outerContent' in sectionConfig) {\n      return (\n        <Fragment key={sectionConfig.key}>\n          {sectionConfig.outerContent}\n        </Fragment>\n      )\n    }\n\n    return (\n      <tr\n        key={sectionConfig.key}\n        role=\"presentation\"\n        className={getSectionClassNames(sectionConfig, this.props.liquid).join(' ')}\n      >\n        {sectionConfig.chunks.map((chunkConfig, i) => this.renderChunk(\n          sectionConfig,\n          sectionIndex,\n          colGroupStats[i],\n          microColGroupNodes[i],\n          chunkConfig,\n          i,\n          (sectionRowMaxHeights[sectionIndex] || [])[i] || [],\n          isHeader,\n        ))}\n      </tr>\n    )\n  }\n\n  renderChunk(\n    sectionConfig: ScrollGridSectionConfig,\n    sectionIndex: number,\n    colGroupStat: ColGroupStat | undefined,\n    microColGroupNode: VNode | undefined,\n    chunkConfig: ScrollGridChunkConfig,\n    chunkIndex: number,\n    rowHeights: number[],\n    isHeader: boolean,\n  ): VNode {\n    if ('outerContent' in chunkConfig) {\n      return (\n        <Fragment key={chunkConfig.key}>\n          {chunkConfig.outerContent}\n        </Fragment>\n      )\n    }\n\n    let { state } = this\n    let { scrollerClientWidths, scrollerClientHeights } = state\n\n    let [sectionCnt, chunksPerSection] = this.getDims()\n    let index = sectionIndex * chunksPerSection + chunkIndex\n    let sideScrollIndex = (!this.context.isRtl || getIsRtlScrollbarOnLeft()) ? chunksPerSection - 1 : 0\n    let isVScrollSide = chunkIndex === sideScrollIndex\n    let isLastSection = sectionIndex === sectionCnt - 1\n\n    let forceXScrollbars = isLastSection && state.forceXScrollbars // NOOOO can result in `null`\n    let forceYScrollbars = isVScrollSide && state.forceYScrollbars // NOOOO can result in `null`\n\n    let allowXScrolling = colGroupStat && colGroupStat.allowXScrolling // rename?\n    let allowYScrolling = getAllowYScrolling(this.props, sectionConfig) // rename? do in section func?\n\n    let chunkVGrow = getSectionHasLiquidHeight(this.props, sectionConfig) // do in section func?\n    let expandRows = sectionConfig.expandRows && chunkVGrow\n    let tableMinWidth = (colGroupStat && colGroupStat.totalColMinWidth) || ''\n\n    let content = renderChunkContent(sectionConfig, chunkConfig, {\n      tableColGroupNode: microColGroupNode,\n      tableMinWidth,\n      clientWidth: scrollerClientWidths[index] !== undefined ? scrollerClientWidths[index] : null,\n      clientHeight: scrollerClientHeights[index] !== undefined ? scrollerClientHeights[index] : null,\n      expandRows,\n      syncRowHeights: Boolean(sectionConfig.syncRowHeights),\n      rowSyncHeights: rowHeights,\n      reportRowHeightChange: this.handleRowHeightChange,\n    }, isHeader)\n\n    let overflowX: ClippedOverflowValue =\n      forceXScrollbars ? (isLastSection ? 'scroll' : 'scroll-hidden') :\n        !allowXScrolling ? 'hidden' :\n          (isLastSection ? 'auto' : 'scroll-hidden')\n\n    let overflowY: ClippedOverflowValue =\n      forceYScrollbars ? (isVScrollSide ? 'scroll' : 'scroll-hidden') :\n        !allowYScrolling ? 'hidden' :\n          (isVScrollSide ? 'auto' : 'scroll-hidden')\n\n    // it *could* be possible to reduce DOM wrappers by only doing a ClippedScroller when allowXScrolling or allowYScrolling,\n    // but if these values were to change, the inner components would be unmounted/remounted because of the parent change.\n    content = (\n      <ClippedScroller\n        ref={this.clippedScrollerRefs.createRef(index)}\n        scrollerElRef={this.scrollerElRefs.createRef(index)}\n        overflowX={overflowX}\n        overflowY={overflowY}\n        liquid={chunkVGrow}\n        maxHeight={sectionConfig.maxHeight}\n      >\n        {content}\n      </ClippedScroller>\n    )\n\n    return createElement(\n      isHeader ? 'th' : 'td',\n      {\n        key: chunkConfig.key,\n        ref: this.chunkElRefs.createRef(index) as any,\n        role: 'presentation',\n      },\n      content,\n    )\n  }\n\n  componentDidMount() {\n    this.updateScrollSyncers()\n    this.handleSizing(false)\n\n    this.context.addResizeHandler(this.handleSizing)\n  }\n\n  componentDidUpdate(prevProps: ScrollGridProps, prevState: ScrollGridState) {\n    this.updateScrollSyncers()\n\n    // TODO: need better solution when state contains non-sizing things\n    this.handleSizing(false, prevState.sectionRowMaxHeights !== this.state.sectionRowMaxHeights)\n  }\n\n  componentWillUnmount() {\n    this.context.removeResizeHandler(this.handleSizing)\n\n    this.destroyStickyScrolling()\n    this.destroyScrollSyncers()\n  }\n\n  handleSizing = (isForcedResize: boolean, sectionRowMaxHeightsChanged?: boolean) => {\n    if (!this.allowSizing()) {\n      return\n    }\n\n    if (!sectionRowMaxHeightsChanged) { // something else changed, probably external\n      this.anyRowHeightsChanged = true\n    }\n\n    let otherState: Partial<ScrollGridState> = {}\n\n    // if reacting to self-change of sectionRowMaxHeightsChanged, or not stable, don't do anything\n    if (isForcedResize || (!sectionRowMaxHeightsChanged && !this.rowUnstableMap.size)) {\n      otherState.sectionRowMaxHeights = this.computeSectionRowMaxHeights()\n    }\n\n    this.setState({\n      shrinkWidths: this.computeShrinkWidths(),\n      ...this.computeScrollerDims(),\n      ...(otherState as any), // wtf\n    }, () => {\n      if (!this.rowUnstableMap.size) {\n        this.updateStickyScrolling() // needs to happen AFTER final positioning committed to DOM\n      }\n    })\n  }\n\n  allowSizing() {\n    let now = new Date()\n\n    if (\n      !this.lastSizingDate ||\n      now.valueOf() > this.lastSizingDate.valueOf() + config.SCROLLGRID_RESIZE_INTERVAL\n    ) {\n      this.lastSizingDate = now\n      this.recentSizingCnt = 0\n      return true\n    }\n\n    return (this.recentSizingCnt += 1) <= 10\n  }\n\n  handleRowHeightChange = (rowEl: HTMLTableRowElement, isStable: boolean) => {\n    let { rowUnstableMap, rowInnerMaxHeightMap } = this\n\n    if (!isStable) {\n      rowUnstableMap.set(rowEl, true)\n    } else {\n      rowUnstableMap.delete(rowEl)\n\n      let innerMaxHeight = getRowInnerMaxHeight(rowEl)\n      if (!rowInnerMaxHeightMap.has(rowEl) || rowInnerMaxHeightMap.get(rowEl) !== innerMaxHeight) {\n        rowInnerMaxHeightMap.set(rowEl, innerMaxHeight)\n        this.anyRowHeightsChanged = true\n      }\n\n      if (!rowUnstableMap.size && this.anyRowHeightsChanged) {\n        this.anyRowHeightsChanged = false\n        this.setState({\n          sectionRowMaxHeights: this.computeSectionRowMaxHeights(),\n        })\n      }\n    }\n  }\n\n  computeShrinkWidths() {\n    let colGroupStats = this.compileColGroupStats(this.props.colGroups.map((colGroup) => [colGroup]))\n    let [sectionCnt, chunksPerSection] = this.getDims()\n    let cnt = sectionCnt * chunksPerSection\n    let shrinkWidths: number[] = []\n\n    colGroupStats.forEach((colGroupStat, i) => {\n      if (colGroupStat.hasShrinkCol) {\n        let chunkEls = this.chunkElRefs.collect(i, cnt, chunksPerSection) // in one col\n        shrinkWidths[i] = computeShrinkWidth(chunkEls)\n      }\n    })\n\n    return shrinkWidths\n  }\n\n  // has the side effect of grooming rowInnerMaxHeightMap\n  // TODO: somehow short-circuit if there are no new height changes\n  private computeSectionRowMaxHeights() {\n    let newHeightMap = new Map<HTMLTableRowElement, number>()\n\n    let [sectionCnt, chunksPerSection] = this.getDims()\n    let sectionRowMaxHeights: number[][][] = []\n\n    for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n      let sectionConfig = this.props.sections[sectionI]\n      let assignableHeights: number[][] = [] // chunk, row\n\n      if (sectionConfig && sectionConfig.syncRowHeights) {\n        let rowHeightsByChunk: number[][] = []\n\n        for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n          let index = sectionI * chunksPerSection + chunkI\n          let rowHeights: number[] = []\n\n          let chunkEl = this.chunkElRefs.currentMap[index]\n          if (chunkEl) {\n            rowHeights = findElements(chunkEl, '.fc-scrollgrid-sync-table tr').map((rowEl: HTMLTableRowElement) => {\n              let max = getRowInnerMaxHeight(rowEl)\n              newHeightMap.set(rowEl, max)\n              return max\n            })\n          } else {\n            rowHeights = []\n          }\n\n          rowHeightsByChunk.push(rowHeights)\n        }\n\n        let rowCnt = rowHeightsByChunk[0].length\n        let isEqualRowCnt = true\n\n        for (let chunkI = 1; chunkI < chunksPerSection; chunkI += 1) {\n          let isOuterContent = sectionConfig.chunks[chunkI] && sectionConfig.chunks[chunkI].outerContent !== undefined // can be null\n\n          if (!isOuterContent && rowHeightsByChunk[chunkI].length !== rowCnt) { // skip outer content\n            isEqualRowCnt = false\n            break\n          }\n        }\n\n        if (!isEqualRowCnt) {\n          let chunkHeightSums: number[] = []\n          for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n            chunkHeightSums.push(\n              sumNumbers(rowHeightsByChunk[chunkI]) + rowHeightsByChunk[chunkI].length, // add in border\n            )\n          }\n\n          let maxTotalSum = Math.max(...chunkHeightSums)\n\n          for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n            let rowInChunkCnt = rowHeightsByChunk[chunkI].length\n            let rowInChunkTotalHeight = maxTotalSum - rowInChunkCnt // subtract border\n\n            // height of non-first row. we do this to avoid rounding, because it's unreliable within a table\n            let rowInChunkHeightOthers = Math.floor(rowInChunkTotalHeight / rowInChunkCnt)\n\n            // whatever is leftover goes to the first row\n            let rowInChunkHeightFirst = rowInChunkTotalHeight - rowInChunkHeightOthers * (rowInChunkCnt - 1)\n\n            let rowInChunkHeights: number[] = []\n            let row = 0\n\n            if (row < rowInChunkCnt) {\n              rowInChunkHeights.push(rowInChunkHeightFirst)\n              row += 1\n            }\n\n            while (row < rowInChunkCnt) {\n              rowInChunkHeights.push(rowInChunkHeightOthers)\n              row += 1\n            }\n\n            assignableHeights.push(rowInChunkHeights)\n          }\n        } else {\n          for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n            assignableHeights.push([])\n          }\n\n          for (let row = 0; row < rowCnt; row += 1) {\n            let rowHeightsAcrossChunks: number[] = []\n\n            for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n              let h = rowHeightsByChunk[chunkI][row]\n              if (h != null) { // protect against outerContent\n                rowHeightsAcrossChunks.push(h)\n              }\n            }\n\n            let maxHeight = Math.max(...rowHeightsAcrossChunks)\n\n            for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n              assignableHeights[chunkI].push(maxHeight)\n            }\n          }\n        }\n      }\n\n      sectionRowMaxHeights.push(assignableHeights)\n    }\n\n    this.rowInnerMaxHeightMap = newHeightMap\n\n    return sectionRowMaxHeights\n  }\n\n  computeScrollerDims() {\n    let scrollbarWidth = getScrollbarWidths()\n    let [sectionCnt, chunksPerSection] = this.getDims()\n    let sideScrollI = (!this.context.isRtl || getIsRtlScrollbarOnLeft()) ? chunksPerSection - 1 : 0\n    let lastSectionI = sectionCnt - 1\n    let currentScrollers = this.clippedScrollerRefs.currentMap\n    let scrollerEls = this.scrollerElRefs.currentMap\n    let forceYScrollbars = false\n    let forceXScrollbars = false\n    let scrollerClientWidths: { [index: string]: number } = {}\n    let scrollerClientHeights: { [index: string]: number } = {}\n\n    for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) { // along edge\n      let index = sectionI * chunksPerSection + sideScrollI\n      let scroller = currentScrollers[index]\n\n      if (scroller && scroller.needsYScrolling()) {\n        forceYScrollbars = true\n        break\n      }\n    }\n\n    for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) { // along last row\n      let index = lastSectionI * chunksPerSection + chunkI\n      let scroller = currentScrollers[index]\n\n      if (scroller && scroller.needsXScrolling()) {\n        forceXScrollbars = true\n        break\n      }\n    }\n\n    for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n      for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n        let index = sectionI * chunksPerSection + chunkI\n        let scrollerEl = scrollerEls[index]\n\n        if (scrollerEl) {\n          // TODO: weird way to get this. need harness b/c doesn't include table borders\n          let harnessEl = scrollerEl.parentNode as HTMLElement\n\n          scrollerClientWidths[index] = Math.floor(\n            harnessEl.getBoundingClientRect().width - (\n              (chunkI === sideScrollI && forceYScrollbars)\n                ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future\n                : 0\n            ),\n          )\n\n          scrollerClientHeights[index] = Math.floor(\n            harnessEl.getBoundingClientRect().height - (\n              (sectionI === lastSectionI && forceXScrollbars)\n                ? scrollbarWidth.x // use global because scroller might not have scrollbars yet but will need them in future\n                : 0\n            ),\n          )\n        }\n      }\n    }\n\n    return { forceYScrollbars, forceXScrollbars, scrollerClientWidths, scrollerClientHeights }\n  }\n\n  updateStickyScrolling() {\n    let { isRtl } = this.context\n    let argsByKey = this.scrollerElRefs.getAll().map(\n      (scrollEl) => [scrollEl, isRtl] as [ HTMLElement, boolean ],\n    )\n\n    let stickyScrollings = this.getStickyScrolling(argsByKey)\n\n    stickyScrollings.forEach((stickyScrolling) => stickyScrolling.updateSize())\n\n    this.stickyScrollings = stickyScrollings\n  }\n\n  destroyStickyScrolling() {\n    this.stickyScrollings.forEach(destroyStickyScrolling)\n  }\n\n  updateScrollSyncers() {\n    let [sectionCnt, chunksPerSection] = this.getDims()\n    let cnt = sectionCnt * chunksPerSection\n    let scrollElsBySection: { [sectionI: string]: HTMLElement[] } = {}\n    let scrollElsByColumn: { [colI: string]: HTMLElement[] } = {}\n    let scrollElMap = this.scrollerElRefs.currentMap\n\n    for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n      let startIndex = sectionI * chunksPerSection\n      let endIndex = startIndex + chunksPerSection\n\n      scrollElsBySection[sectionI] = collectFromHash(scrollElMap, startIndex, endIndex, 1) // use the filtered\n    }\n\n    for (let col = 0; col < chunksPerSection; col += 1) {\n      scrollElsByColumn[col] = this.scrollerElRefs.collect(col, cnt, chunksPerSection) // DON'T use the filtered\n    }\n\n    this.scrollSyncersBySection = this.getScrollSyncersBySection(scrollElsBySection)\n    this.scrollSyncersByColumn = this.getScrollSyncersByColumn(scrollElsByColumn)\n  }\n\n  destroyScrollSyncers() {\n    mapHash(this.scrollSyncersBySection, destroyScrollSyncer)\n    mapHash(this.scrollSyncersByColumn, destroyScrollSyncer)\n  }\n\n  getChunkConfigByIndex(index: number) { // somewhat expensive for something so simple\n    let chunksPerSection = this.getDims()[1]\n    let sectionI = Math.floor(index / chunksPerSection)\n    let chunkI = index % chunksPerSection\n    let sectionConfig = this.props.sections[sectionI]\n\n    return sectionConfig && sectionConfig.chunks[chunkI]\n  }\n\n  forceScrollLeft(col: number, scrollLeft: number) {\n    let scrollSyncer = this.scrollSyncersByColumn[col]\n\n    if (scrollSyncer) {\n      scrollSyncer.forceScrollLeft(scrollLeft)\n    }\n  }\n\n  forceScrollTop(sectionI: number, scrollTop: number) {\n    let scrollSyncer = this.scrollSyncersBySection[sectionI]\n\n    if (scrollSyncer) {\n      scrollSyncer.forceScrollTop(scrollTop)\n    }\n  }\n\n  _handleChunkEl(chunkEl: HTMLTableCellElement | null, key: string) {\n    let chunkConfig = this.getChunkConfigByIndex(parseInt(key, 10))\n\n    if (chunkConfig) { // null if section disappeared. bad, b/c won't null-set the elRef\n      setRef(chunkConfig.elRef, chunkEl)\n    }\n  }\n\n  _handleScrollerEl(scrollerEl: HTMLElement | null, key: string) {\n    let chunkConfig = this.getChunkConfigByIndex(parseInt(key, 10))\n\n    if (chunkConfig) { // null if section disappeared. bad, b/c won't null-set the elRef\n      setRef(chunkConfig.scrollerElRef, scrollerEl)\n    }\n  }\n\n  getDims() {\n    let sectionCnt = this.props.sections.length\n    let chunksPerSection = sectionCnt ? this.props.sections[0].chunks.length : 0\n\n    return [sectionCnt, chunksPerSection]\n  }\n}\n\nScrollGrid.addStateEquality({\n  shrinkWidths: isArraysEqual,\n  scrollerClientWidths: isPropsEqual,\n  scrollerClientHeights: isPropsEqual,\n})\n\nfunction sumNumbers(numbers: number[]) { // TODO: general util\n  let sum = 0\n\n  for (let n of numbers) {\n    sum += n\n  }\n\n  return sum\n}\n\nfunction getRowInnerMaxHeight(rowEl: HTMLElement) {\n  let innerHeights = findElements(rowEl, '.fc-scrollgrid-sync-inner').map(getElHeight)\n\n  if (innerHeights.length) {\n    return Math.max(...innerHeights)\n  }\n\n  return 0\n}\n\nfunction getElHeight(el: HTMLElement) {\n  return el.offsetHeight // better to deal with integers, for rounding, for PureComponent\n}\n\nfunction renderMacroColGroup(colGroupStats: ColGroupStat[], shrinkWidths: number[]) {\n  let children = colGroupStats.map((colGroupStat, i) => {\n    let width = colGroupStat.width\n\n    if (width === 'shrink') {\n      width = colGroupStat.totalColWidth + sanitizeShrinkWidth(shrinkWidths[i]) + 1 // +1 for border :(\n    }\n\n    return ( // eslint-disable-next-line react/jsx-key\n      <col style={{ width }} />\n    )\n  })\n\n  return createElement('colgroup', {}, ...children)\n}\n\nfunction compileColGroupStat(colGroupConfig: ColGroupConfig): ColGroupStat {\n  let totalColWidth = sumColProp(colGroupConfig.cols, 'width') // excludes \"shrink\"\n  let totalColMinWidth = sumColProp(colGroupConfig.cols, 'minWidth')\n  let hasShrinkCol = hasShrinkWidth(colGroupConfig.cols)\n  let allowXScrolling = colGroupConfig.width !== 'shrink' && Boolean(totalColWidth || totalColMinWidth || hasShrinkCol)\n\n  return {\n    hasShrinkCol,\n    totalColWidth,\n    totalColMinWidth,\n    allowXScrolling,\n    cols: colGroupConfig.cols,\n    width: colGroupConfig.width,\n  }\n}\n\nfunction sumColProp(cols: ColProps[], propName: string) {\n  let total = 0\n\n  for (let col of cols) {\n    let val = col[propName]\n\n    if (typeof val === 'number') {\n      total += val * (col.span || 1)\n    }\n  }\n\n  return total\n}\n\nconst COL_GROUP_STAT_EQUALITY = {\n  cols: isColPropsEqual,\n}\n\nfunction isColGroupStatsEqual(stat0: ColGroupStat, stat1: ColGroupStat): boolean {\n  return compareObjs(stat0, stat1, COL_GROUP_STAT_EQUALITY)\n}\n\n// for memoizers...\n\nfunction initScrollSyncer(isVertical: boolean, ...scrollEls: HTMLElement[]) {\n  return new ScrollSyncer(isVertical, scrollEls)\n}\n\nfunction destroyScrollSyncer(scrollSyncer: ScrollSyncer) {\n  scrollSyncer.destroy()\n}\n\nfunction initStickyScrolling(scrollEl: HTMLElement, isRtl: boolean) {\n  return new StickyScrolling(scrollEl, isRtl)\n}\n\nfunction destroyStickyScrolling(stickyScrolling: StickyScrolling) {\n  stickyScrolling.destroy()\n}\n","import { createPlugin, config } from '@fullcalendar/common'\n\nimport premiumCommonPlugin from '@fullcalendar/premium-common' // eslint-disable-line import/no-duplicates\n// ensure ambient declarations\nimport '@fullcalendar/premium-common' // eslint-disable-line import/no-duplicates\n\nimport { ScrollGrid } from './ScrollGrid'\n\nexport { ScrollGrid }\nexport { setScrollFromLeftEdge } from './scroll-left-norm'\n\nexport default createPlugin({\n  deps: [\n    premiumCommonPlugin,\n  ],\n  scrollGridImpl: ScrollGrid,\n})\n\nconfig.SCROLLGRID_RESIZE_INTERVAL = 500\n"]},"metadata":{},"sourceType":"module"}